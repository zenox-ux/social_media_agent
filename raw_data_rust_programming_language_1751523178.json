[
  {
    "type": "full_submission",
    "title": "I've used (and loved) Rust for ~10 years. Here are the ways it disappoints me.",
    "url": "https://www.reddit.com/r/rust/comments/1e978l7/ive_used_and_loved_rust_for_10_years_here_are_the/",
    "score": 1004,
    "selftext": "# Intro\n\nI've used Rust for somewhere around ~10 years at this point, since shortly before Rust 1.0 was released in May 2015. I've worked on a bunch of different projects in Rust including desktop GUI apps, server backends, CLI programs, sandboxed scripting interfaces via WASM, and multiple game-related projects. Most recently, I've done a ton of work contributing to the Bevy game engine. \n\nI also have a good amount of experience with several other languages: Java, Python, Typescript, Elixir, C, and several more niche ones with correspondingly less experience. Not enough to say that I'm an expert in them, but enough that I'm familiar with and have experienced the major tradeoffs between them. I'll mainly be comparing Rust to Java, as that's what I've been using a lot lately outside of Rust.\n\nOut of all of these, Rust is by far my favorite language, and I'm not planning on going anywhere! I use it daily, and it's been a joy to work with 90% of the time. \n\nOf course like any language that gets actually _used_, it has it's problems. Moments where you go \"what the heck? Why? Oh, hrmm, ok maybe this? Not quite, this is frustrating\". _I'm not here to talk about those cases_.\n\nWhat I'm here to talk about are the _major_ pain points I've experienced. The problems that have come up repeatedly, significantly impact my ability to get stuff done, and can't be fixed without fundamental changes. \n\nA quick list of things I'm not going to cover:\n\n* Async/await: Actually fairly decent in Rust in my opinion. Pretty solid given the constraints of no extra cost or builtin runtime, cancellation, etc. I remember the pressure to get this shipped around Rust 2018 edition, and I think it came out pretty well despite that. The main issues are around mixing sync and async code, Pin, multiple executors in the ecosystem, and whether zero-cost is a sensible tradeoff to begin with. It's been discussed to death, I don't have anything to add to it. Maybe virtual threads would've been nicer and just eat the runtime costs, I don't know. I feel that just using async by itself in e.g. a web server is pretty solid now that we've gotten async traits. \n* Library ecosystem: Yeah I wished it was more stable and bug-free (e.g. comparing winit to sdl), but that's not really a language issue. There's not much for me to talk about here.\n\nOnto my complaints.\n\n# Result<T, E>\n\nWhen I first started with Rust, I loved that errors are just another type. Implicit errors are terrible; forcing the user to be aware that a function could error, and handle that error is a great design!\n\nAs I've used Rust for both library and application code over the years, I've grown more and more disillusioned with this take. \n\nAs a library author, having to make new error types and convert between them for every possible issue _sucks_. There's nothing worse than adding a dependency, calling a function from it, and then having to go figure out how to add it's own error type into your wrapper error type. Crates like `thiserror` (I think the main one I've tried) help a bit, but in my experience are still a poor experience. And that's all for 1 function - if you make a second function doing something different, you're probably going to want a whole new error type for that. \n\nThen there's application code. Usually you don't care about how/why a function failed - you just want to propagate the error up and display the end result to the user. Sure, there's `anyhow`, but this is something that languages like Java handles _way_ better in my experience. Besides the obvious issue of wanting a single dynamically dispatched type, the real issue to me is backtraces. \n\nWith Java, I see a perfect log of exactly what function first threw an error, and how that got propagated up the stack to whatever logging or display mechanism the program is using. With Rust, there's no backtraces whenever you propagate an error with the ? operator. Of course backtraces have a performance cost, which is why it's not built-in. \n\nLibraries hit this issue too - it's really hard to figure out what the issue is when a user reports a bug, as all you have is \"top level function failed\" with no backtrace, unless it's a panic. Same with tracking down why your dependencies are throwing errors themselves.\n\nRust got the \"forcing developers to think about errors\" part right. Unlike Java, it's immediately obvious that a function can fail, and you can't accidentally skip dealing with this. I've seen so many bugs in other languages where some function threw an error, and completely unwound the program when it should have been dealt with 10 layers lower with a retry. \n\nHowever, while it's zero-cost and very explicit, I think Rust made a mistake in thinking that people would care (in most cases) _why_ a function failed beyond informing the user. I really think it's time Rust standardized on a single type that acts like Box<dyn Error> (including supports for string errors), and automatically attaches context whenever it gets propagated between functions. It wouldn't be for all uses cases, as it's not zero-cost and is less explicit, but it would make sense for a lot of use cases.\n\nSmall aside, there's also error messages. Should errors be formatted like \"Error: Failed to do x.\", or \"Failed to do x\"? Period at the end? Capitalization? This is not really the language's fault, but I wish there was an ecosystem-wide standard for formatting errors.\n\n# Modules\n\nThe orphan rule sucks sometimes, and the module system is maybe too flexible. \n\nWorking on Bevy, which has a monorepo consisting of bevy_render, bevy_pbr, bevy_time, bevy_gizmos, bevy_ui, etc, and a top-level bevy crate that re-exports everything, I've felt the pain on this pretty strongly recently.\n\nOrganizing code across crates is pretty difficult. You can re-export types willy-nilly between crates, make some parts pub(crate), pub(super), or pub(crate::random::path). For imports, the same problems apply, and you can choose to re-export specific modules or types from within other modules. It's really easy to accidentally expose types you didn't mean to, or to re-export a module and lose out on the module-documentation you've written for it.\n\nMore than any real issue, it's just too much power. It's strange because Rust loves to be explicit, but gives you a _lot_ of leeway in how you arrange your types. Say what you will about Java's \"one file = one class; module paths follow filesystem folders\" approach, but it's nothing if not explicit. It's much easier to jump into a large project in Java and know exactly where a type can be found, than it is for Rust.\n\nThe orphan rule is a problem too, but something I don't have as much to say about. It just sometimes really gets in the way, even for library developers due to splitting things across crates for one project (and Rust really encourages you to split things up into multiple crates).\n\n# Compile times and IDE tooling\n\nCompile times and error checking in my IDE are too slow. People do great work speeding up rustc and rust-analyzer, and I don't mean to demean their efforts. But Rust fundamentally treats 1 crate = 1 compilation unit, and that really hurts the end-user experience. Touching one function in Bevy's monorepo means the entire crate gets recompiled, and every other crate that depends on it. I really really wish that modifying a function implementation or file was as simple as recompiling that function / file and patching the binary.\n\nRust analyzer has the same problem. IntelliJ indexes my project once on startup, and instantly shows errors for the rest of my development time. Rust analyzer feels like it's reindexing the entire project (minus dependencies) every time you type. Fine for small projects, but borderline unusable at Bevy's scale.\n\nI'm not a compiler dev - maybe these are fundamental problems that can't be fixed, especially with considerations for macros, build scripts, cargo features, and other issues. But I really wish the compiler could just maintain a graph of my project's structure and detect that I've only modified this one part. This happens all the time in UI development with the VDOM, is there any reason this can't be implemented in cargo/rustc?\n\n# Conclusion\n\nAnd that's the end of the post. Writing is not my strong suit, and this was hastily put together at night to get down some of the thoughts I've been having lately, as I don't have time to sit down and write a proper article on my rarely-used blog. Take everything I've said with the knowledge that I've only given surface-level consideration to it, and haven't looked too deeply into existing discussion around these issues.\n\nThat said, these are the major issues that have been bothering me the last few years. I'm curious to hear other peoples' thoughts on whether they face the same issues.",
    "top_comments": [
      {
        "body": "If rust analyzer is doing a long recompile on every change, it probably means it's compiling with different features or environment variables than what you are building your app with. By default RA uses the same target directory as as `cargo build` to store build artifacts and if they are making incompatible builds they end up causing each other to keep doing full builds.\n\nThis can be especially common with Bevy if you enable the bevy/dynamic_linking feature for your builds but not Rust analyzer's.\n\nEasiest fix is to tell RA to use a different target directory, see rust-analyzer.cargo.targetDir here: https://rust-analyzer.github.io/manual.html\n\nAnother fix would be to make sure all features and environment variables are the same so they can reuse each other's build artifacts, this can be tricky though.",
        "score": 164
      },
      {
        "body": "I thought I was the only person in the world that actually likes the async/await implementation in Rust.",
        "score": 341
      },
      {
        "body": "`anyhow` actually supports backtraces. You just need to set `RUST_BACKTRACE=1` and call `.backtrace()` on the error:\n\nhttps://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.backtrace",
        "score": 192
      },
      {
        "body": "I am still confused about modules. Way more than async or borrowing. \n\nI think it is made worse by being easy to work with without understanding it.   \nYou can quite easily survive with copy/paste and following the existing pattern. Add file here, pub mode her, use there. And suddenly when something slightly different needs to happen I have no idea how it works.",
        "score": 119
      },
      {
        "body": "Disclaimer: I wrote this as a hasty not-quite-rant on some issues I've been thinking about recently. The tone came out as fairly negative, so I want to re-iterate: I love Rust! \n\nThe language really is great - I wouldn't have used it for 10 years, and continue to use it every day if I hated it. Huge props to everyone that's worked on it - everyone has put in a great deal of effort that shouldn't be ignored, and I want to take a second to recognize that effort and not just complain :)",
        "score": 163
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Announcing Rust 1.85.0 and Rust 2024 | Rust Blog",
    "url": "https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html",
    "score": 1143,
    "selftext": "",
    "top_comments": [
      {
        "body": "Async closures finally arrived!",
        "score": 375
      },
      {
        "body": "The updates to the `std::env::home_dir` function is funny. I have never seen something get deprecated, be deprecated for years, then get fixed and un-deprecated!",
        "score": 181
      },
      {
        "body": "Async closures ❤️",
        "score": 101
      },
      {
        "body": "\\`\\`\\`  \n[`if let` temporary scope](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) — Changes the scope of temporaries for `if let` expressions.  \n\\`\\`\\`\n\nGates of Valhalla just opened, did they?",
        "score": 194
      },
      {
        "body": "Makes me wonder. Do we know if there will be an update of [Programming Rust](https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/)?",
        "score": 38
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Rust continues to be the most-admired programming language with an 83% score this year.",
    "url": "https://survey.stackoverflow.co/2024/technology#2-programming-scripting-and-markup-languages",
    "score": 692,
    "selftext": "",
    "top_comments": [
      {
        "body": "Cargo is also the most admired embedded technology, whatever thats supposed to mean in this context.\n\nAnyway Cargo is definitly the best programming language build tool and package manager in my opinion, so well deserved.",
        "score": 325
      },
      {
        "body": "Are we even surprised any more?",
        "score": 120
      },
      {
        "body": "Not surprised, Rust really feels great to work with like 95% of the time but the last 5% are pure agony when you either realize you designed a feature completely antithetical to the borrow checker or run into wild type errors with async. But other than that, just slap some `.clone()` here and there and it feels like you're working with a very high level and ergonomic language. Sum types, pattern matching and strong typing with traits really makes most other languages feel clunky and weird, every time I work with e.g. TypeScript at work I miss `Option`/`Result` and pattern matching.",
        "score": 89
      },
      {
        "body": "no surprises here",
        "score": 45
      },
      {
        "body": "I've been using rust for 2 years now. I stopped being really excited by the thoughtful design every time I use it. Instead I somewhat accepted it as the normal programming flow. Everytime I am forced to use another language like C, Java or Python I am so frustrated at the lack of coherent error/package handling, sum types, iterators and so much more. It's insane how much better those languages could be...",
        "score": 40
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Announcing Rust 1.86.0 | Rust Blog",
    "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0.html",
    "score": 784,
    "selftext": "",
    "top_comments": [
      {
        "body": "Nice, with get_disjoint, I can now retire most of https://github.com/mcmah309/indices",
        "score": 109
      },
      {
        "body": "Trait upcasting!\n\nImma upcast myself from `Human` to `Mammal` now :3",
        "score": 319
      },
      {
        "body": "[`Vec::pop_if()`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop_if) is a highly welcome addition.",
        "score": 113
      },
      {
        "body": "Nice, safe functions can now be marked with `#[target_feature]`",
        "score": 49
      },
      {
        "body": ">Rustdoc - Add a sans-serif font setting.\n\nOooh, looks good!",
        "score": 48
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Best programming language to ever exist",
    "url": "https://www.reddit.com/r/rust/comments/1jczcv2/best_programming_language_to_ever_exist/",
    "score": 303,
    "selftext": "I've been learning Rust for the past week, and coming from a C/C++ background, I have to say it was the best decision I've ever made. I'm never going back to C/C++, nor could I. Rust has amazed me and completely turned me into a Rustacean. The concept of lifetimes and everything else is just brilliant and truly impressive! Thank the gods I'm living in this timeline. I also don't fully understand why some people criticize Rust, as I find it to be an amazing language.\n\nI don’t know if this goes against the \"No low-effort content\" rule, but I honestly don’t care. If this post gets removed, so be it. If it doesn’t, then great. I’ll be satisfied with replies that simply say \"agreed,\" because we both know—Rust is the best.",
    "top_comments": [
      {
        "body": "It's brilliant, really, but remember to report back when you've done more than dipped your toes. :-) \n\nEither you're a freaking genius or you've only just started along a steep learning curve.",
        "score": 212
      },
      {
        "body": "Man breathe!! Don't advertise your love to the public too soon. Nurture it first. Try to go above the language and learn skills that remain despite the changes in the software world. You may use this excitement to make the language better. See open issues and try to contribute.",
        "score": 23
      },
      {
        "body": "A whole week, really? \n\nSo you are in the honeymoon phase and you already divorced your breadwinner? Seems a bit… hasty.\n\nHopefully you didn’t quote your day job. Tools come and go.",
        "score": 19
      },
      {
        "body": "everyone talks about lifetimes and memory safety and all that but what really made me love rust is the whole cargo crates ecosystem. It’s so simple to add dependencies to your projects compared to C/C++.",
        "score": 17
      },
      {
        "body": "You should try some GC language with strong types",
        "score": 12
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "\"AI is going to replace software developers\" they say",
    "url": "https://www.reddit.com/r/rust/comments/1jworgh/ai_is_going_to_replace_software_developers_they/",
    "score": 426,
    "selftext": "A bit of context: Rust is the first and only language I ever learned, so I do not know how LLMs perform with other languages. I have never used AI for coding ever before. I'm very sure this is the worst subreddit to post this in. Please suggest a more fitting one if there is one.\n\nSo I was trying out egui and how to integrate it into an existing Wgpu + winit codebase for a debug menu. At one point I was so stuck with egui's documentation that I desperately needed help. Called some of my colleagues but none of them had experience with egui. Instead of wasting someone's time on reddit helping me with my horrendous code, I left my desk, sat down on my bed and doom scrolled Instagram for around five minutes until I saw someone showcasing Claudes \"impressive\" coding performance. It was actually something pretty basic in Python, however I thought: \"Maybe these AIs could help me. After all, everyone is saying they're going to replace us anyway.\"\n\nYeah I did just that. Created an Anthropic account, made sure I was using the 3.7 model of Claude and carefully explained my issue to the AI. Not a second later I was presented with a nice answer. I thought: \"Man, this is pretty cool. Maybe this isn't as bad as I thought?\"\n\nI really hoped this would work, however I got excited way too soon. Claude completely refactored the function I provided to the point where it was unusable in my current setup. Not only that, but it mixed deprecated winit API (WindowBuilder for example, which was removed in 0.30.0 I believe) and  hallucinated non-existent winit and Wgpu API. This was really bad. I tried my best getting it on the right track but soon after, my daily limit was hit.\n\nI tried the same with ChatGPT and DeepSeek. All three showed similar results, with ChatGPT giving me the best answer that made the program compile but introduced various other bugs.\n\nTwo hours later I asked for help on a discord server and soon after, someone offered me help. Hopped on a call with him and every issue was resolved within minutes. The issue was actually something pretty simple too (wrong return type for a function) and I was really embarrassed I didn't notice that sooner.\n\nAnyway, I just had a terrible experience with AI today and I'm totally unimpressed. I can't believe some people seriously think AI is going to replace software engineers. It seems to struggle with anything beyond printing \"Hello, World!\". These big tech CEOs have been taking about how AI is going to replace software developers for years but it seems like nothing has really changed for now. I'm also wondering if Rust in particular is a language where AI is still lacking.\n\nDid I do something wrong or is this whole hype nothing more than a money grab?",
    "top_comments": [
      {
        "body": "I think what people don't quite gasp is that if the end result is worse but much cheaper, some industries will take it anyway.\n\n\nIn my industry we have the position of analyst, which is someone who's always done most of the nume crunching in excel. For around 5 years, new positions either demand or at least ask for python knowledge, and I can tell you that a majority of them either don't want to learn or are horrible at it. These people are very likely to embrace LLMs to avoid learning python, just because the bar is very low already.",
        "score": 388
      },
      {
        "body": "The 'generate big chunk of code' approaches are dogshit. You can produce something sometimes with them that somewhat resembles working software, but it's a crapshoot. Current AI techniques are great at filling in patterns though – for example, write out 2 unit tests, for the next 5 only write out the descriptions – most of the time it'll get them right. AI is pretty good at repeating patterns and structures that are within its context and slightly changing details in a way that still makes sense.",
        "score": 125
      },
      {
        "body": "AI doesnt understand the actual libraries unless its actually consumed them in the training process and examples of their use. Its not really \"thinking\" it works great with say python,java,javascript and the most popular libraries for those languages because there is a truly staggering amount of data for them to work off of.\n\nthe way to get the most out of ai is context and constraints which rust is actually really good at so for more general questions or situations not related to a specific crate/library it tends to do really well. I strongly recommend tools like repomix when using claude or other llm's to help give the needed context for it to make or suggest or explain changes that are far more grounded in the reality of your actual code.",
        "score": 91
      },
      {
        "body": "AI seems to be extremely \"your mileage may vary\".\n\nIt also seems to work a LOT better for Python. My guess is that's partially because there is so much tutorial content out there for that language, but also because it's a very straightforward language where all the context you need to remember is what values you have stuffed in which variables. While with Rust, even variables with basically the same meaning can have very different types (Option, Result, NonZero, borrowed, CoW, Vec/Slice/array, ...).\n\nI also suspect a lot of people are using AI as an alternative to \"using templates\" or \"copy/pasting stuff from stackoverflow\" for very common types of code, and I'm sure it can do that pretty well.",
        "score": 30
      },
      {
        "body": "Again and again...\n\nAI is a great tool but very different from \"classic\" tools, because it requires a supervisor that knows what they are doing and challenges the tool outcome. It is very much unlike tools like RA or clippy that are always correct.\n\nVast majority of developers are aware of that but for some reason, r/rust has extremely strong sentiment against ai.\n\nAI at this point cannot replace a developer but it can extremely empower them. I like to compare it to the history of vehicles. Cars replaced horses. Drivers are still required but we slowly experiment with autonomous cars. Smiths are now nearly unneeded but car mechanic, who were not existing before, are more demanded than ever. It's really very similar. Devs need to adapt and they become more efficient.",
        "score": 6
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "I built a Programming Language Using Rust.",
    "url": "https://www.reddit.com/r/rust/comments/1h06uqw/i_built_a_programming_language_using_rust/",
    "score": 493,
    "selftext": "Hey Reddit!\n\nI have been working on this project for a long time (almost a year now). \n\nI am 16 years old, and, I built this as a project for my college application (looking to pursue CS)\n\nIt is called [Tidal](http://tidal.pranavv.co.in), and it is my own programming language written in Rust.\n\n[https://tidal.pranavv.co.in](https://tidal.pranavv.co.in) <= You can find everything on this page, including the Github Repo and Documentation, and Downloads.\n\nIt is a simple programming language, with a syntax that I like to call - \"Javathon\" 😅; it resembles a mix between JavaScript and Python.\n\nPlease do check it out, and let me know what you think!\n\n",
    "top_comments": [
      {
        "body": "We have been using tidal in production at my company for the last 23 minutes with excellent results.",
        "score": 581
      },
      {
        "body": "> `yeet` will identify as a while loop. \n\nnooooo, why isn't that a replacement for `return`? :(\n\nBut nice idea with the \"brainrot\" variant xD Why need a tool for obfuscation, if you can code with it? xD",
        "score": 112
      },
      {
        "body": "Love the work. Once you're looking for a job in 5 years, one of the requirements will be\n\n - 10 years of experience in the Tidal programming language. ",
        "score": 90
      },
      {
        "body": "[deleted]",
        "score": 58
      },
      {
        "body": "Mate I think you're killing it for 16. Keep it up.",
        "score": 37
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Should I learn Rust or C as my second language after Python?",
    "url": "https://www.reddit.com/r/rust/comments/1lj79dz/should_i_learn_rust_or_c_as_my_second_language/",
    "score": 73,
    "selftext": "I'm at an intermediate–advanced level in Python and I've done several projects. Now I'm looking to pick up a second language that brings me closer to systems-level programming.\n\nInitially, I was leaning toward C because it's closer to the metal and widely used for low-level work. But I've heard a lot about Rust being safer and more modern — though also harder to learn, especially with its ownership model.\n\nI want to understand how things work under the hood and eventually build low-level tools or libraries.\n\nSo, should I start with C and then move to Rust later? Or jump into Rust directly and learn systems concepts along the way?\n\nWould love to hear what worked for you, especially if you also started with Python.",
    "top_comments": [
      {
        "body": "I would suggest learning some C basics and assembly since it will help motivate ownership and why Rust is considered 'safer'. But you don't have to do that.",
        "score": 166
      },
      {
        "body": "I would recommend Rust. It will be a lot more familiar than C if you're coming from Python. The tooling for Rust is much better, so you'll be actually building things sooner.\n\nC isn't really lower level than Rust. It's just smaller, provides a much less powerful standard library, and makes a lot of stuff harder and more error prone. I'm not sure if there's really much to learn from spending a week writing a hash table that barely functions for example.\n\nYou can still learn C afterwards, at which point you'll hate how clunky everything is, how nothing important is really portable, and how much more work simple things are, but you'll be better at it for knowing there is another way.",
        "score": 122
      },
      {
        "body": "Learning the basics of C will help you appreciate Rust (and probably Python too) a lot better.  I wouldn't try and master it, but getting the basics of memory management and data structures will make some important stuff in Rust make more sense.",
        "score": 12
      },
      {
        "body": "> I want to understand how things work under the hood and eventually build low-level tools or libraries.\n\nStart with C then.\n\nUnlike Rust, C won't hand hold you from making mistakes, instead leaving you to understand how things work under the hood if you wanna make your code work for you.\n\nI hate C, but credit where credit is due.",
        "score": 56
      },
      {
        "body": "I’m a huge rust fan and use it professionally every day. I would recommend learning C first. It will make you appreciate rust when you learn it next.",
        "score": 9
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Graphite (now a top-100 Rust project) turns Rust into a functional, visual scripting language for graphics operations — REQUESTING HELP to implement compiler bidirectional type inference",
    "url": "https://www.reddit.com/r/rust/comments/1lor3b4/graphite_now_a_top100_rust_project_turns_rust/",
    "score": 386,
    "selftext": "Just now, [Graphite](https://graphite.rs) has broken into the top 100 Rust projects on GitHub by [star](https://github.com/GraphiteEditor/Graphite/stargazers) count, and it has been today's #1 [trending repo](https://github.com/trending?since=daily) on all of GitHub regardless of language.\n\nIt's a community-driven open source project that is a comprehensive 2D content creation tool for graphic design, digital art, and interactive real-time motion graphics. It also, refreshingly, has a high-quality UI design that is modern, intuitive, and user-friendly. The vision is to become the Blender equivalent of 2D creative tools. [Here's a 1-minute video](https://static.graphite.rs/content/index/sizzle-compilation.mp4) showing the cool, unique, visually snazzy things that can be made with it.\n\nGraphite features a node-based procedural editing environment using a bespoke functional programming language, Graphene, that we have built on top of Rust itself such that it uses Rust's data types and `rustc` to transform artist-created documents into portable, standalone programs that can procedurally generate parametric artwork. Think: something spanning the gamut from Rive to ImageMagick.\n\nFor the juicy technical deets, give the *Developer Voices* [podcast episode](https://www.youtube.com/watch?v=ZUbcwUC5lxA) a listen where we were interviewed about how our Graphene engine/language lets even nontechnical artists \"paint with Rust\", sort of like if Scratch used Rust as its foundation. We go into detail on the unique approach of turning a graphics editor into a compiled programming language where the visual editor is like an IDE for Rust code.\n\n### Here's the ask: help implement bidirectional type inference in our language's compiler\n\nThe Graphene language — while it is built on top of Rust and uses Rust's compiler, data types, traits, and generics — also has its own type checker. It supports generics, but is somewhat rudimentary and needs to be made more powerful, such as implementing [Hindley–Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system) or similar, in order for Graphene types to work with contextual inference just like Rust types do.\n\nThis involves the Graphene compiler internals and we **only have one developer with a compilers background** and he's a student with limited free time spread across all the crucial parts of the Graphite project's engineering. But we know that /r/rust is — well... — naturally a place where many talented people who love building compilers and hobby language implementations hang out.\n\nThis type system project should last a few weeks for someone with the right background— but for more than a year, working around having full type inference support has been a growing impediment that is impacting how we can keep developing ergonomic graphics tooling. For example, a graphics operation can't accept two inputs and use the type of the first to pick a compatible generic type for the second. This results in painful workarounds that confuse users. Even if it's just a short-term involvement, even temporarily expanding our team beyond 1 knowledgeable compiler developer would have an outsized impact on helping us execute our mission to bring programmatic graphics (and Rust!) into the hands of artists.\n\nIf you can help, we will work closely with you to get you up to speed with the existing compiler code. If you're up for the fun and impactful challenge, the best way is to [join our project Discord](https://discord.graphite.rs) and say you'd like to help in our `#💎graphene-language` channel. Or you can [comment on the GitHub issue](https://github.com/GraphiteEditor/Graphite/issues/1621).\n\nBesides compilers, we also need general help, especially in areas of our bottlenecks: code quality review, and helping design API surfaces and architecture plans for upcoming systems. If you're an experienced engineer who could help with any of those for a few hours a week, or with general feature development, please also come get involved! Graphite is one of the easiest open source projects to start contributing to according to many of our community members; we really strive to make it as frictionless as possible to [start out](https://graphite.rs/volunteer/guide/). Feel free to drop by and leave a code review on any [open PRs](https://github.com/GraphiteEditor/Graphite/pulls) or ask what kind of task best fits your background (graphics, algorithm design, application programming, bug hunting, and of course most crucially: programming language compilers).\n\nThank you! Now let's go forth and get artists secretly addicted to Rust 😀 In no time at all, they will be writing custom Rust functions to do their own graphical operations.\n\n---\n\nP.S. If you are attending [Open Sauce](https://opensauce.com/) in a few weeks, come visit our booth. We'd love to chat (and give you swag).",
    "top_comments": [
      {
        "body": "If you haven't yet, you should post this on /r/ProgrammingLanguages  as well.",
        "score": 54
      },
      {
        "body": "Graphite’s moving up like it’s got its own Rust compiler!",
        "score": 24
      },
      {
        "body": "I don't personally have the skillset to help you out, but I have to say this is a really great example of how to ask for help in a wider community, good context, good 'pitch' - I think the project is exceptionally cool as well, which possibly biases me of course.",
        "score": 24
      },
      {
        "body": "I’ve been meaning to dig in and check this out. Tomorrow!!!",
        "score": 15
      },
      {
        "body": "I'll definitely check this out! You should post the demo video over at /r/generative too, I think that's the exact crowd for this",
        "score": 8
      }
    ]
  },
  {
    "type": "full_submission",
    "title": "Learning Rust as my first programming language, could use some advice",
    "url": "https://www.reddit.com/r/rust/comments/1jd3fns/learning_rust_as_my_first_programming_language/",
    "score": 16,
    "selftext": "Greetings, I'm learning rust as my first programming language which I've been told can be challenging but rewarding. I got introduced to it through blockchain and smart contracts, and eventually stumbled upon a creative coding framework called nannou which I also found interesting\n\n  \nThe difficulties I'm facing aren't really understanding programming concepts and the unique features of rust, but more-so how to actually use them to create things that allow me to put what I learned into practice. I'm currently using the rust book, rustlings, rustfinity, and a \"Learn to Code with Rust\" course from Udemy. Any advice on how to learn rust appropriately and stay motivated would be appreciated :)",
    "top_comments": [
      {
        "body": "Rust is very far from a good first programming language.  I strongly recommend to start with a language that will give you a faster iteration and feedback loop such as Python or JavaScript.\n\nRust is absolutely not good for iterative programming because your program itself won't even run unless it's \"correct\".  It will not allow you any room for error and you will become very frustrated spending all your time on compiler errors instead of just your own logic and \"tinkering\".",
        "score": 61
      },
      {
        "body": "I have also learnt Rust as my first programming language and imo the best way to do this, would be to just trudge through it. There’s now shortcut or anything but the benefits are insane because when I went to learn python, I spent more time in correcting the syntax than the logic. I would recommend joining the rust discord where many people will help you understand rust. To be fair, I learnt a bit of C++ at the start to understand coding, but it really won’t be that much of a difference. Another way would be to type out the code from the official rust book into a notes folder and then understanding what the code does. If you don’t understand, there’s ChatGPT to ONLY CLEAR OUT DOUBTS, not to teach you, which can be helpful sometimes but if ChatGPT can’t explain it to you, then the rust discord would be an optimal place to ask your questions. Don’t jump into projects just yet, instead try going through the official rust book, and then do rustlings, some basic projects like a CLI tool, external crate usage, etc. It’s just all part of the journey",
        "score": 9
      },
      {
        "body": "I did that too, been working as a Rust developer for some years now. My advice is to find a project that's really interesting to you and that you are going to use. You can talk about it on the various forums and I'm sure you will get help and even contributions.\nIt doesn't have to be big, but it must be useful to you so you have a reason to improve on it. It then can be a playground for you when you want to discover new crates for example.",
        "score": 7
      },
      {
        "body": "One thing that will massively help you in getting to grips with the language is getting your editor set-up correctly. i.e. the rust-up toolchain with cargo, rustc, and clippy etc. After that, it's just a matter of learning to fix the squiggley lines.",
        "score": 5
      },
      {
        "body": "Rust is like a very good second or third programming language.\n\nLearn python or something. People telling you to learn C hate you as much as C developers hate themselves.",
        "score": 32
      }
    ]
  },
  {
    "type": "individual_post",
    "title": "Pipelining might be my favorite programming language feature",
    "selftext": "Not solely a Rust post, but that won't stop me from gushing over Rust in the article (wrt its pipelining just being nicer than both that of enterprise languages and that of Haskell)",
    "score": 292
  },
  {
    "type": "individual_post",
    "title": "What programming languages do you want to work with next?",
    "selftext": "After looking at this year's Stack Overflow survey, I saw that Rust will continue to be the most loved programming language with an admiration score of *82%*. Then I saw what programming languages other people want to try, depending on their current one. See [here](https://survey.stackoverflow.co/2024/technology#worked-with-vs-want-to-work-with-language-worked-want-prof).\n\nThis got me wondering: What are some programming languages you *(Rustaceans)* want to work with next year and why?",
    "score": 140
  },
  {
    "type": "individual_post",
    "title": "Experienced developer but total beginner when programming in Rust",
    "selftext": "I have almost 10 YOE in various fields, but mostly oriented towards web backend, devops and platform engineering, have experience in C, Swift, PHP, Javascript, Java.\n\nI feel pretty confident doing stuff in those languages, especially in the web domain. I recently (\\~3 months ago) started my journey in Rust. So far, I started a couple of smaller and bigger projects, and actually, functionality wise I did pretty good.  \n\n\nHowever, I struggle really hard to understand where, how and when to use certain patterns, which I did not encounter in that way in other languages that I worked with, such as:\n\n1.  When passing things to functions, do you default to borrow, clone, move?\n2.  When are lifetimes mostly used, is the idea to avoid it whenever possible, are they used as a \"last resort\" or a common practice?\n3. When to use a crate such as **thiserror** over **anyhow** or vice versa?\n4. How common it is to implement traits such as Borrow, Deref, FromStr, Iterator, AsRef and their general usage?\n5. Vector iteration: loop vs. iter() vs. iter().for\\_each() vs. enumerate() vs. into\\_iter() vs. iter\\_mut() ...why, when?\n6. \"Complex\" (by my current standards) structure when defining trait objects with generic and lifetimes..how did you come to the point of 'okay I have to define \n\n&#8203;\n\n    trait DataProcessor<'a, T>\n    where\n        T: Debug + Clone + 'a, // `T` must implement Debug and Clone\n    {\n        fn process(&self, data: &'a T);\n    }\n\nI read \"The Rust Programming Language\", went through Rustlings, follow some creators that do a great job of explaining stuff and started doing \"Rust for Rustaceans\" but at this point I have to say that seems to advanced for my level of understanding.\n\n  \nHow to get more proficient in intermediate to advanced concepts, because I feel at this point I can code to get the job done, and want to upgrade my knowledge to write more maintainable, reusable, so called \"idiomatic\" Rust. How did you do it?\n\n  \nP.S. Also another observation - while I used other languages, Rust \"feels\" good in a particular way that if it compiles, there's a high chance it actually does the intended job, seems less prone to errors.",
    "score": 131
  },
  {
    "type": "individual_post",
    "title": "Programming a commercial game from scratch in Rust and how (in comments)",
    "selftext": "",
    "score": 140
  },
  {
    "type": "individual_post",
    "title": "An interpreted programming language made in Rust!",
    "selftext": "It has a standard lexer and parser, and uses a stack based VM to interpret bytecode files, kind of like Java.\n\nI’m currently working on making it Turing complete (developing if statements at the moment)\n\nIts syntax will be similar to TypeScript (when I add static types), Rust, and Go.\n\nThis won’t be good for production anytime soon, and I expect it to have a lot of bugs and security issues because I’m not a very good programmer. I hope to work out these kinks in the future with some help or by myself and make a neat programming language!",
    "score": 90
  },
  {
    "type": "individual_post",
    "title": "I’m building a programming language called Razen that compiles to Rust",
    "selftext": "Hey,\n\nI’ve been working on a programming language called **Razen** that compiles into Rust. It’s something I started for fun and learning, but it’s grown into a real project.\n\nRazen currently supports:\n\n* Variables\n* Functions\n* Conditionals and loops\n* Strings, arrays, and some built-in libraries\n\nThe compiler is written in Rust, and right now I’m working toward making Razen self-compiling (about 70–75% there). I’m also adding support for API-related and early AI-focused libraries.\n\nI tried to keep the syntax clean and a little different — kind of a blend of Python and Rust, but with its own twist.\n\nHere’s a small Razen code example using a custom random library:\n\n**random\\_lib.rzn**\n\n    type freestyle;\n    \n    # Import libraries\n    lib random;\n    \n    # variables declaration\n    let zero = 0;\n    let start = 1;\n    let end = 10;\n    \n    # random number generation\n    let random_number = Random[int](start, end);\n    show \"Random number between \" + start + \" and \" + end + \": \" + random_number;\n    \n    # random float generation\n    let random_float = Random[float](zero, start);\n    show \"Random float between \" + zero + \" and \" + start + \": \" + random_float;\n    \n    # random choice generation\n    take choise_random = Random[choice](\"apple\", \"banana\", \"cherry\");\n    show \"Random choice: \" + choise_random;\n    \n    # random array generation\n    let shuffled_array = Random[shuffle]([1, 2, 3, 4, 5]);\n    show \"Shuffled array: \" + shuffled_array;\n    \n    # Direct random operations\n    show \"Random integer (1-10): \" + Random[int](1, 10);\n    show \"Random float (0-1): \" + Random[float](0, 1);\n    show \"Random choice: \" + Random[choice]([\"apple\", \"banana\", \"cherry\"]);\n    show \"Shuffled array: \" + Random[shuffle]([1, 2, 3, 4, 5]);\n\nIf anyone’s into language design, compiler internals, or just wants to see how Razen compiles to Rust, the repo is here:   \n**GitHub**: [https://github.com/BasaiCorp/Razen-Lang](https://github.com/BasaiCorp/Razen-Lang)\n\nAlways open to thoughts, feedback, or ideas. Thanks.",
    "score": 82
  },
  {
    "type": "individual_post",
    "title": "How to use Blender as a scene editor for your engine-less game",
    "selftext": "Hi, this is my first devlog for our upcoming game, Black Horizon: Armada\\\nCheck out our [kickstarter](https://www.kickstarter.com/projects/blackhorizonarmada/black-horizon-armada-strategy-card-game) if you're interested!\n\nFor this game I decided not to use an off-the-shelf game engine, because I like being able to decide on the code architecture, instead of inheriting it from the game engine I've chosen.\\\nHowever, off-the-shelf game engines do have their merits and for me a big one is the fact that you start off with a visual scene editor you can start dropping assets into.\\\nWe could define all our game objects in code, and this can be very powerful, but sometimes it's just way more convenient to place some objects using a 3D editor.\\\nWe could of course make our own scene editor, and that does sound like a lot of fun. But thinking about it we usually already use a piece of software that has the functionality to put 3D objects in a scene. Namely the one we use to create the 3D assets, in our case Blender.\\\nSo the question becomes: If we have Blender, couldn't we do all our scene creation in there and forgo the need for another scene editor?\n\n## How do we get our data into our game?\nI started off thinking I would use a well-known intermediary format like glTF, to export from Blender and then I would import that into my game.\nHowever, I realized that the import code that was running at startup was doing some non-trivial stuff, like parsing a json file and the glTF file contained a lot of information I wasn't using, and it was just bigger and slower to load than I wanted.\nSo I figured I would add an extra data ingest step to the pipeline, where I would take the glTF file, extract the data I wanted and store it into a binary data format, that would be small and fast to load at startup.\n\nHowever at this point the question arose:\nWhy do I need the glTF file at all?\nIf I know how I want the data to be stored, why not export it like that in the first place?\n* This would save a step in the pipeline.\n* I'm already more familiar with how my data is in Blender than I am with glTF.\n* I could avoid a coordinate system transformation.\n* I could make use of any data in Blender.\n\nBecause we keep the Blender file as the original source of data, our export file only has to contain anything we actually want to use in our game. If we change our mind about what we need during development we can always change it and re-export.\n\nThe data we'll be exporting today consists of transforms and vertex data for all the meshes in the file. And transforms and view angles for the cameras.\n\nHowever, at the end of this you should have no problem adding additional data or changing the format around entirely yourself.\n\n## How do we add functionality to our objects?\nIn most off-the-shelf game engines, the workflow would be something like: You make an object and then you attach some kind of components to it that define its behavior.\nWe could try to emulate this, and find a way to add components in our Blender scene.\nWe could use text fields and specify our components in text. Or we could make a whole python interface that lets us edit things more like a traditional game engine.\nBut that means that we would need a lot of knowledge duplicated between our game and our editor, and having duplicated knowledge in different environments is always a pain.\nSo instead we'll just get the data from Blender that is nice to create there, like meshes and transforms.\nAnd then we'll add behavior to things in code.\n\n## How do we reference the data in our file?\nMy first thought was to add an array of strings to our file, and then the objects could have an index into that array for their name.\\\nHowever, working with strings has a couple of drawbacks:\n* Doing lots of string comparisons to find an object is slow.\n* If we refer to an object using a string, we'll only notice that reference is broken when we actually try to compare the string.\n* I'm never planning to show these strings to the final user, so they're wasting space.\n\nSo what's the alternative?\\\nWe could use indices, that would be faster for the computer to get the right object and it wouldn't waste space.\\\nHowever it would be even worse to work with than the string literals, since at least the string gave us a hint which object we wanted before things broke.\n\nSo what I'v decided to do is use an enum. It's an index to the computer but in our code it gets to be a proper name, and we'll get compile errors if we break the reference.\n\nThe way this'll work is that we keep track of the names of the objects as we're adding them to these arrays and then we generate the code for the enum as a separate file, that can go directly into the source of our program.\n\nOne drawback to this is that we can't add more objects and hot reload, we can only modify our existing objects.\nHowever since I'm using hard references to the object in the code anyway, adding objects without changing the code would have limited effect to begin with.\nSo if you want a more generic approach where you just throw any scene at your game and it works, you'll have to live without referencing objects directly from code any way.\n\n## Deciding on the specifics of how the data is layed out\n\n### Endianness:\nWhen converting from and to raw bytes, we have to take into account [Endianness](https://en.wikipedia.org/wiki/Endianness), which is the order in which bytes within a word are transmitted.\nWe can use either Little- or Big-Endian as long as we're consistent.\nI'm opting for Little-Endian since it's native on most modern machines, so it should be slightly faster to work with.\n\n### Padding:\nI’ll pack everything tightly to save space.\nIf you wanted to use this data exactly as it’s loaded into memory without having to do any copying you might have to take some alignment requirements into account and have to insert some padding because of it.\n\n### Data:\nOur file will contain one scene:\n\n#### Scene\n* u32 mesh count\n* mesh data\n* u32 camera count\n* camera data\n* u32 vertex count\n* vertex data\n\n#### Mesh:\n* transform\n* vertex span\n\n#### Camera:\n* f32 view angle\n* transform\n\n#### Vertex:\n* vec3 pos\n* color\n\n#### Transform:\n* vec3 position\n* quat rotation\n* vec3 scale\n\n#### Vertex span:\n* u32 begin,\n* u32 end\n\n#### Vec3:\n* f32 x\n* f32 y\n* f32 z\n\n#### Quat:\n* f32 x\n* f32 y\n* f32 z\n* f32 w\n\n#### Color:\n* u8 r\n* u8 g\n* u8 b\n* u8 a\n\nFor our scene data I've opted to first put all our meshes, then all our cameras.\nAlternatively we could have opted to store all our objects in whatever order and tag them with type information.\nBut this would mean that we have to switch on the type byte all the time when working with the data, and I'm not particularly attached to their order anyway.\n\nI've also chosen to put all the vertex data together at the end, and refer to it with begin- and end-indices, instead of having it right after the mesh. This is because I'm planning to upload all the vertex data to the GPU in one big buffer for our rendering.\nWhich will likely be more efficient for rendering than having a bunch of smaller vertex buffers, but you should analyze your own data, and its lifetime and access patterns, to make a good decision for your case.\n\n## Retrieve the data from Blender\nWe'll be writing a python script to export the data.\nAnother interesting possibility is to use the [blend rust crate](https://crates.io/crates/blend). So we could write our export code in rust and we wouldn't have to open Blender to export. However I've found that the .blend file format is not designed for this usecase and changes too much between versions for this to be stable.\n\n### The Python console\nIf you're new to Blender python I highly recommend changing one of your panes to Python console as it gives you a great way of trying things out.\n\nA nice way to get started is to select an object and get a reference to it through the context.\n\n``` python\nobj = bpy.context.active_object\n```\nTo explore Blender python in the console it's nice to type the beginning of something and then press tab to see how you could continue it.\nfor example type\n``` python\nobj.\n```\nand then press tab to see a list of all the properties you could access on the object we just got.\\\nIn Blender there are lots of different types of objects. A useful property to figure out what kind of object we are dealing with is the type property.\n``` python\nobj.type\n```\nwill return us a string identifying the type of object we selected.\nThe type specific data of the object can be found in the data property.\nTry typing\n``` python\nobj.data.\n```\nand pressing tab to see a list of all the type specific properties in our object.\\\n\\\nFor exploring purposes getting the active object is great, but we would like our export script to not be affected by what happens to be selected at the time.\nTo access data in a more systematic way we can use\n``` python\nbpy.data\n```\nYou can think of bpy.data as accessing what's in the file where bpy.context helps you access things depending on the current state of the editor.\n\nIf you get stuck with the script the console is a great place to come back to, in order to test small parts of our logic, but for now let's move on to writing an export script we can run again and again.\n\nfrom the console we can always use bpy because it's imported by default, but if we want to access it from another script we'll have to import it like so:\n``` python\nimport byp\n```\n\n### Script\nWe'll import the [python struct library](https://docs.python.org/3/library/struct.html) which we'll be using to store our data in binary format.\n``` python\nfrom struct import *\n```\nBecause we don't know upfront how long the different data sections will be I'll make an intermediate object that'll hold them and some other info like the counts that we can then write to a file.\nI'll also keep track of the names of the objects.\n\n``` python\nclass ExportData:\n    def __init__(self):\n        self.mesh_data = bytearray()\n        self.mesh_names = []\n        self.camera_data = bytearray()\n        self.camera_names = []\n        self.vertex_data = bytearray()\n        self.vertex_count = 0\n```\nHere we're taking any object and doing the appropriate thing if it's a mesh or a camera.\n``` python\ndef write_object(export_data, obj):\n    if (obj.type == \"MESH\"):\n        write_mesh_obj(export_data, obj)\n    elif (obj.type == \"CAMERA\"):\n        write_cam_obj(export_data, obj)\n```\n\nWhen we write a mesh object we store the vertex data in the vertex array and keep track of it with a begin and end value we store in our mesh data.\n``` python\ndef write_mesh_obj(export_data, obj):\n    export_data.mesh_names.append(obj.name)\n    write_obj_trans(export_data.mesh_data, obj)\n    (vb, ve) = write_mesh_vertices(export_data, obj)\n    export_data.mesh_data.extend(pack(\"<II\", vb, ve))\n```\n\nCamera data can just go in the camera buffer\n``` python\ndef write_cam_obj(export_data, obj):\n    export_data.camera_names.append(obj.name)\n    write_camera(export_data.camera_data, obj)\n\ndef write_camera(arr, obj):\n    write_obj_trans(arr, obj)\n    angle = obj.data.angle\n    arr.extend(pack(\"<f\", angle))\n```\n\nWe'll get the translation, rotation and scale from the world matrix and store them\n``` python\ndef write_obj_trans(arr, obj):\n    mat = obj.matrix_world\n    write_vec3(arr, mat.translation)\n    write_quat(arr, mat.to_quaternion())\n    write_vec3(arr, mat.to_scale())\n```\nBlender works with n-gons, which is great for modeling but when it comes time to render we need things in triangles, so we'll have to convert them and we might as well do it here so it doesn't have to happen at runtime.\nThe conversion takes some creative looping.\n\nWe can choose between some different types of primitives, in this case I went with a triangle list as it's easy to work with.\n\nIf we have a lot of vertices that are used between multiple triangles it might pay off to store the vertex data per point and then use indices to store our triangles.\nHowever this only works when all the data is shared and I find I often have some data like uv, normal or color that isn't. But it's worth considering.\n\nWe have to take care when exporting the vertex colors that they may not exist, in which case we'll default to black with full alpha.\n\n``` python\ndef write_mesh_vertices(export_data, obj):\n    begin = export_data.vertex_count\n    mesh = obj.data\n    verts = mesh.vertices\n    has_colors = len(mesh.vertex_colors) > 0\n    if (has_colors):\n        colors = mesh.vertex_colors[0].data\n    polygons = mesh.polygons\n    p_begin_polygon = 0;\n    for polygon in polygons:\n        for i in range(1, len(polygon.vertices)-1):\n            polygon_indices = [0, i, i+1]\n            for ii in range(0, 3):\n                polygon_index = polygon_indices[ii]\n                p = p_begin_polygon + polygon_index\n                vert_index = polygon.vertices[polygon_index]\n                pos = verts[vert_index].co\n                color = (0, 0, 0, 1)\n                if (has_colors):\n                    color = colors[p].color\n                write_vec3(export_data.vertex_data, pos)\n                write_color(export_data.vertex_data, color)\n                export_data.vertex_count += 1\n        p_begin_polygon += len(polygon.vertices)\n    end = export_data.vertex_count\n    return (begin, end)\n```\n\nHere you can see the struct library in action.\nThe string \"<fff\" signifies that we're writing in little endian (<) 3 f32's (fff)\n``` python\ndef write_vec3(arr, v):\n     arr.extend(pack(\"<fff\", v[0], v[1], v[2]))\n```\n\nVery similar for quaternion\n``` python\ndef write_quat(arr, q):\n     arr.extend(pack(\"<ffff\", q[1], q[2], q[3], q[0]))\n```\nWe'll convert our colors from f32 to normalized u8, keep in mind that blender vertex colors are in sRGB color space.\n``` python\ndef write_color(arr, color):\n    r = f32_to_normalized_u8(color[0])\n    g = f32_to_normalized_u8(color[1])\n    b = f32_to_normalized_u8(color[2])\n    a = f32_to_normalized_u8(color[3])\n    arr.extend(pack(\"<BBBB\", r, g, b, a))\n\ndef f32_to_normalized_u8(x):\n    return max(0, min(int(x * 255.0), 255))\n```\n\nTo save our data we simply open a file in binary write mode (\"wb\") and write the counts and data for our different sections.\n``` python\ndef write_data_to_file(export_data, path):\n    file = open(path, \"wb\")\n    file.write(pack(\"<I\", len(export_data.mesh_names)))\n    file.write(export_data.mesh_data)\n    file.write(pack(\"<I\", len(export_data.camera_names)))\n    file.write(export_data.camera_data)\n    file.write(pack(\"<I\", export_data.vertex_count))\n    file.write(export_data.vertex_data)\n    file.close()\n```\nHere we generate the enum file to reference our objects from code:\n``` python\ndef write_enums_to_file(export_data, path):\n    file = open(path, \"w\")\n    if (len(export_data.mesh_names) > 0):\n        file.write(\"pub enum MeshId {\\n\")\n        for name in export_data.mesh_names:\n            file.write(\"    \")\n            file.write(name)\n            file.write(\",\\n\")\n        file.write(\"}\\n\")\n    if (len(export_data.camera_names) > 0):\n        file.write(\"pub enum CameraId {\\n\")\n        for name in export_data.camera_names:\n            file.write(\"    \")\n            file.write(name)\n            file.write(\",\\n\")\n        file.write(\"}\\n\")\n    file.close()\n```\nI put all the preceding python code in a separate file called export_utils.py file that can be imported by multiple blend files.\n\nThe following code is the code I put directly into a text object in Blender and run.\n\nIn Blender, current working directory isn't always the one that contains the file you are working on, so we'll get it like this:\n``` python\nimport bpy\nfilepath = bpy.path.abspath(\"//\")\n```\nWe would like to import the export_utils.py file we made earlier, that's located in the same folder. In order to do that we have to add the path to the system path.\n``` python\nimport sys\nsys.path += [filepath]\n```\nNow we can import our export_utils\n``` python\nfrom export_utils import *\n```\nI also set the current working directory so we can have relative paths to the files we would like to create.\n``` python\nimport os\nos.chdir(filepath)\n```\nNow all we have to do is loop over all the objects in our scene, add them to our export data and save the relevant files.\n``` python\nexport_data = ExportData()\nfor obj in bpy.data.objects:\n    write_object(export_data, obj)\n\nwrite_data_to_file(export_data, \"test.data\")\nwrite_enums_to_file(export_data, \"test.rs\")\n```\n## Importing into Rust\n\nWe'll define a trait for anything we can unpack from our file format.\nWe'll pass it a buffer of bytes and a cursor indicating where we are currently reading. We could have gotten away with only passing in the buffer slice and chopping off the bytes we've used, but I find this easier to debug.\nOf course our unpack function can be passed any old slice of bytes that may be invalid, because it's too short or because we're expecting values in a certain range, so we'll have to wrap our result in an error.\nI've chosen to use the [anyhow crate](https://crates.io/crates/anyhow) for our error handling, since I think it's a bit more convenient for this type of situation where you mostly expect things to work and want to print a message if it doesn't.\n\n``` rust\npub trait Unpack {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> where Self: Sized;\n}\n```\nWe'll implement our new trait for the basic types we're using\n\n``` rust\nimpl Unpack for u8 {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        let result = *buffer.get(*cursor).context(\"Unexpected End Of Buffer\")?;\n        *cursor += 1;\n        Ok(result)\n    }\n}\n\nimpl Unpack for u32 {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self::from_le_bytes(unpack_fixed_size_array(cursor, buffer)?))\n    }\n}\n\nimpl Unpack for f32 {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self::from_le_bytes(unpack_fixed_size_array(cursor, buffer)?))\n    }\n}\n\npub fn unpack_fixed_size_array<const SIZE: usize>(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<[u8; SIZE]> {\n    if *cursor + SIZE > buffer.len() { bail!(\"Unexpected End Of Buffer\") }\n    let mut bytes = [0; SIZE];\n    bytes.copy_from_slice(&buffer[*cursor..*cursor + SIZE]);\n    *cursor += SIZE;\n    Ok(bytes)\n}\n```\nWe'll define the data types we're importing.\n``` rust\n#[derive(Debug)]\npub struct Scene {\n    pub meshes: Vec<Mesh>,\n    pub cameras: Vec<Camera>,\n    pub vertices: Vec<Col32Vertex>,\n}\n\n#[derive(Debug)]\npub struct Mesh {\n    pub transform: Transform,\n    pub vert_span: VertexSpan,\n}\n\n#[derive(Debug)]\npub struct Camera {\n    pub transform: Transform,\n    pub view_angle: f32,\n}\n\n#[derive(Debug)]\npub struct Col32Vertex {\n    pub pos: Vec3,\n    pub color: Col32,\n}\n\n#[derive(Debug)]\npub struct Transform {\n    pub t: Vec3,\n    pub r: Quat,\n    pub s: Vec3,\n}\n\n#[derive(Debug)]\npub struct VertexSpan {\n    pub begin: u32,\n    pub end: u32,\n}\n\n#[derive(Debug)]\npub struct Vec3 {\n    pub x: f32,\n    pub y: f32,\n    pub z: f32,\n}\n\n#[derive(Debug)]\npub struct Quat {\n    pub x: f32,\n    pub y: f32,\n    pub z: f32,\n    pub w: f32,\n}\n\n#[derive(Debug)]\npub struct Col32 {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n    pub a: u8,\n}\n```\nAnd we'll implement our Unpack trait for them:\n``` rust\nimpl Unpack for Scene {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        let mesh_count = u32::unpack(cursor, buffer)?;\n        let mut meshes = Vec::new();\n        for _ in 0..mesh_count {\n            let mesh = Mesh::unpack(cursor, buffer)?;\n            meshes.push(mesh);\n        }\n\n        let camera_count = u32::unpack(cursor, buffer)?;\n        let mut cameras = Vec::new();\n        for _ in 0..camera_count {\n            let cam = Camera::unpack(cursor, buffer)?;\n            cameras.push(cam);\n        }\n\n        let vertex_count = u32::unpack(cursor, buffer)?;\n        let mut vertices = Vec::new();\n        for _ in 0..vertex_count {\n            vertices.push(Col32Vertex::unpack(cursor, buffer)?);\n        }\n\n        Ok(Scene {\n            meshes,\n            cameras,\n            vertices,\n        })\n    }\n}\n\nimpl Unpack for Mesh {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            transform: Unpack::unpack(cursor, buffer)?,\n            vert_span: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Camera {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            transform: Unpack::unpack(cursor, buffer)?,\n            view_angle: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Col32Vertex {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            pos: Unpack::unpack(cursor, buffer)?,\n            color: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Transform {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            t: Unpack::unpack(cursor, buffer)?,\n            r: Unpack::unpack(cursor, buffer)?,\n            s: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for VertexSpan {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            begin: Unpack::unpack(cursor, buffer)?,\n            end: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Vec3 {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            x: Unpack::unpack(cursor, buffer)?,\n            y: Unpack::unpack(cursor, buffer)?,\n            z: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Quat {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            x: Unpack::unpack(cursor, buffer)?,\n            y: Unpack::unpack(cursor, buffer)?,\n            z: Unpack::unpack(cursor, buffer)?,\n            w: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n\nimpl Unpack for Col32 {\n    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n        Ok(Self {\n            r: Unpack::unpack(cursor, buffer)?,\n            g: Unpack::unpack(cursor, buffer)?,\n            b: Unpack::unpack(cursor, buffer)?,\n            a: Unpack::unpack(cursor, buffer)?,\n        })\n    }\n}\n```\nA lot of our Unpack implementations boil down to: Call unpack for all the members.\nAnd it starts feeling a bit repetetive.\nThere are some different ways we could alleviate the amount of boiler plate code:\n\n1. Use a macro to generate the code ([this](https://github.com/dtolnay/proc-macro-workshop/tree/master?tab=readme-ov-file#derive-macro-derivebuilder) could be a place to start).\n2. [Write our own Serde format](https://serde.rs/data-format.html).\n\nBoth of those would mean we wouldn't have to implement our unpack function manually.\nBut they also make things quite a bit more complicated, so I've chosen to have it like this for simplicity.\n\nOkay okay, just for fun, here's a derive macro in case you're into that kind of thing ;)\n``` rust\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{ parse_macro_input, Data, DataStruct, DeriveInput, Fields };\n\n#[proc_macro_derive(Unpack)]\npub fn unpack(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    let ident = &input.ident;\n\n    match &input.data {\n        Data::Struct(DataStruct { fields: Fields::Named(fields), .. }) => {\n            let field_names = (&fields.named).iter().map(|field| &field.ident);\n            let output = quote! {\n                impl Unpack for #ident {\n                    fn unpack(cursor: &mut usize, buffer: &[u8]) -> anyhow::Result<Self> {\n                        Ok(Self {\n                            #(\n                                #field_names: Unpack::unpack(cursor, buffer)?,\n                            )*\n                        })\n                    }\n                }\n            };\n\n            TokenStream::from(output)\n        }\n        _ => unimplemented!(),\n    }\n}\n```\nWhere were we? Oh yeah! Importing our data.\n\nIf we want to include our data in our executable we can now:\n``` rust\nconst LOAD_PATH: &str = \"src/test.data\";\n\nfn test_include() {\n    let bytes = include_bytes!(\"test.data\");\n    if let Some(scene) = try_unpack_scene_bytes(bytes) {\n        debug_test_scene(&scene);\n    }\n}\n\nfn try_unpack_scene_bytes(bytes: &[u8]) -> Option<Scene> {\n    let mut cursor = 0;\n    match Scene::unpack(&mut cursor, bytes) {\n        Ok(scene) => Some(scene),\n        Err(err) => {\n            println!(\"Error while unpacking scene: {err:?}\");\n            None\n        }\n    }\n}\n\nfn debug_test_scene(scene: &Scene) {\n    let cam = &scene.cameras[test::CameraId::Camera as usize];\n    println!(\"{cam:?}\");\n\n    let cube = &scene.meshes[test::MeshId::Cube as usize];\n    println!(\"{cube:?}\");\n\n    let cube_verts = &scene.vertices[cube.vert_span.begin as usize..cube.vert_span.end as usize];\n    let first_vert = &cube_verts[0];\n    println!(\"{first_vert:?}\");\n    println!();\n}\n```\nIf we want to load our data at runtime:\n``` rust\nfn test_load() {\n    match std::fs::read(LOAD_PATH) {\n        Ok(bytes) => {\n            if let Some(scene) = try_unpack_scene_bytes(&bytes) {\n                debug_test_scene(&scene);\n            }\n        }\n        Err(_) => todo!(),\n    }\n}\n```\nWe can even hot reload the data when it changes.\\\nI'm using the [notify crate](https://crates.io/crates/notify) to detect when the file is modified.\nWhen creating a watcher we pass in a closure. I've opted to keep the closure as simple as possible and use a channel to send the result to our main thread.\nWe can then in what would be our game loop, check if there are any messages and do whatever we want to do if the file has changed, for now I'm just calling our test_load function.\n``` rust\nfn test_hot_reload() {\n    let (send, recv) = std::sync::mpsc::channel();\n    let mut watcher = notify::recommended_watcher(move |res: Result<notify::Event, notify::Error>| {\n        send.send(res).unwrap()\n    }).unwrap();\n    watcher.watch(std::path::Path::new(LOAD_PATH), notify::RecursiveMode::NonRecursive).unwrap();\n\n    loop {\n        match recv.try_recv() {\n            Ok(res) => {\n                match res {\n                    Ok(event) => {\n                        if let EventKind::Modify(_) = event.kind {\n                            test_load();\n                        }\n                    }\n                    Err(e) => println!(\"watch error: {:?}\", e),\n                }\n            }\n            Err(err) => {\n                match err {\n                    std::sync::mpsc::TryRecvError::Empty => {}\n                    std::sync::mpsc::TryRecvError::Disconnected => panic!(\"channel disconnectd\"),\n                }\n            }\n        }\n    }\n}\n```\nNow all that's left to do is try it out!\n``` rust\nfn main() {\n    println!(\"test include\");\n    test_include();\n\n    println!(\"test load\");\n    test_load();\n\n    println!(\"test hot reload\");\n    test_hot_reload();\n}\n```\nThank you for making it all the way to the end <3\n\nI hope this was interesting!\\\nPlease let me know if you have any thoughts or questions :)\\\n",
    "score": 70
  },
  {
    "type": "individual_post",
    "title": "What are future feature of the rust programming language?",
    "selftext": "By future feature i means the most impactful feature that will exist",
    "score": 74
  },
  {
    "type": "individual_post",
    "title": "The State of Game Dev in Rust 2024: A Newcomer's Perspective",
    "selftext": "After taking about a yearlong break from game dev due to personal and professional parts of my life taking priority, I got the itch to dig back in again. Making games is where I started with programming, although my career has taken me down other avenues. But I also come back to it. I was checking out Raylib, drawn toward its simple API and stability. As I was writing C, it got me thinking, I'd really prefer using Rust! I've dabbled in Rust over the years—read The Book, made a simple CLI to learn, peeked around the landscape—but never committed to it in any serious way. I saw there are Raylib bindings for Rust, which then led me down a rabbithole for the last month to explore the state of game development in Rust. Here's what I see and where I think we can head from here! \n\nFirst, a very brief intro. I'm a hobbyist game developer. I started game programming at a summer camp that used C# and XNA when I was a teenager. I've done full stack web development for my day job for the past 13 years. I've written a lot of Ruby and TypeScript. I've made a bunch of small games in a variety of languages and toolings, from C# to Haxe to Lua to Ruby to Godot. I've released a few small games. I wrote a book for beginners on game programming with Ruby, and I've made a handful of Godot tutorial videos on YouTube. I'm by no means a professional game developer, but I'm also not totally new to this whole thing.\n\nMy motivations and aspirations are the following: 1. make small games that I can finish 2. learn Rust & lower level programming 3. contribute to the community in a meaningful way to help others make games. I'm personally interested in making 2D action, puzzle, and role playing games, as well as simple 3D games (think PS1 era).\n\n(Reddit made me break this up into multiple posts, the essay is continued in the comments. [I also put it up on a blog if that's preferred for reading.](https://games.brettchalupa.com/devlog/the-state-of-game-dev-in-rust-2024/))",
    "score": 64
  },
  {
    "type": "individual_post",
    "title": "I wrote my own programming language interpreter in Rust – here is what I learned",
    "selftext": "I’ve been working on an interpreter for ApLang, a programming language I wrote in Rust. It’s based on the AP Computer Science Principles spec, a high school class.\n\nThis was one of my favorite projects to work on. Writing a \"toy\" language is one thing, but turning it into something relatively stable was much more challenging.\n\n**Design Choices**  \nI intentionally chose not to implement a mark-and-sweep garbage collector since speed isnt the priority - portability and flexibility are. Instead I focused on making the language easy to extend and run in multiple environments.\n\n**Lessons Learned**\n\n* Inline documentation is taken for granted. Right now, all standard library docs are managed in separate Markdown files. This worked fine early on, but as the library grows, it’s becoming unmanageable. I’m working on a macro to generate documentation inline, similar to rustdoc, which should make things much easier to maintain.\n* WASM support for Rust is really solid. Getting ApLang to compile for the browser wasn’t difficult - most of the issues with the online playground came from Web Workers' awful API, not from WASM itself.\n* Pattern matching is a lifesaver. Writing the parser and AST traversal felt clean and ergonomic thanks to Rust’s match expressions.\n* Pretty errors are important for learning. Since the users will be students, feedback is even more important than normal. One goal I have is to have error messages of high enough quality to aid in the teaching process. In my opinion quality error messages are the #1 thing that elevates a language out of the \"toy\" space.   \n\n**What’s Next?**  \nI’m still improving ApLang and adding features - especially around documentation and ease of use. I am also working on adding even more expressive errors slowly.  \n  \n If you’re interested, you can check it the project out here: [https://aplang.org](https://aplang.org)\n\nI’d love to hear your thoughts!",
    "score": 48
  },
  {
    "type": "individual_post",
    "title": "Humble Tech Book Bundle includes two Rust books (Rust for Rustaceans and The Rust Programming Language)",
    "selftext": "",
    "score": 53
  },
  {
    "type": "individual_post",
    "title": "Rust on the Raspberry Pi Pico: Programming the \"Programmable IO\" (PIO)",
    "selftext": "The Raspberry Pi Pico is a $5 microprocessor with two ARM processors which you can program with Rust. For example, for about $15, you can create a theremin-like musical instrument.\n\nIn addition to the two main processors, the Pico includes 8 additional teeny-tiny processors called PIOs (programmable IO). I recently completed a project in Rust (and also MicroPython) to build the theremin.\n\nHere is a summary of what might surprise a Rust programmer using PIO:\n\n* The PIO processors are called \"state machines\", but they are not state machines in the formal computer science sense \\[update: except when they are -- see discussion below\\].\n* You only get 2 general-purpose variables `x` and `y` and two special registers. (But there are workarounds).\n* PIO is an assembly language. Your longest PIO program can be only 32 instructions long. (Again, there are workarounds this and for all most all of the surprises.)\n* PIO \"inputs\" into \"outputs\" and \"transmits\" from \"receive\", because things are named from Rust's perspective, not from PIOs.\n* Non-blocking input gets it default value from `x`. This is documented in the C++ SDK and the 600- and 1300-page datasheets but is confusing if you didn't look it up.\n* Likewise, don't guess how a $2 ultrasonic range finder works. It contains its own microprocessor, and I found it unintuitive.\n\n*Part 2*\n\n* By default, constants are limited to the range 0 to 31. Worse the Rust PIO assembler doesn't tell you if you go over and behavior is then undefined.\n* You can test `x!=y` but not `x==y`. You can test `pin`, but not `!pin`. So, you may need to reverse some of your conditionals.\n* When you finish a loop, your loop variable will have a value of 4,294,967,295.\n* In the PIO program all pins are called `pin` or `pins` but can refer to different pins. The table below summarizes how to configure them in Rust to refer to what you want.\n* Debugging is limited, but you can write values out of PIO that Rust can then print to the console.\n* Rust's Embassy \"tasks\" are so good that you can create a theremin on one processor without using PIO. Only PIO, however, gives you the real-time determinism needed for some applications.\n\nReferences:\n\n* Open source project: [CarlKCarlK/pico\\_pio](https://github.com/CarlKCarlK/pico_pio)\n* (Free) Rust article with details: [https://towardsdatascience.com/nine-pico-pio-wats-with-rust-part-1-9d062067dc25](https://towardsdatascience.com/nine-pico-pio-wats-with-rust-part-1-9d062067dc25)\n* Similar free MicroPython details: [https://medium.com/towards-data-science/nine-pico-pio-wats-with-micropython-part-1-82b80fb84473](https://medium.com/towards-data-science/nine-pico-pio-wats-with-micropython-part-1-82b80fb84473)\n\nhttps://preview.redd.it/83a30e0lm7ge1.png?width=611&format=png&auto=webp&s=33070fa7e41025b8d1f648efe3b025524b62ee12",
    "score": 41
  },
  {
    "type": "individual_post",
    "title": "How would you learn rust as a programming beginner?",
    "selftext": "Hello everybody, I will always been tangentially interested in learning how to program rust. I became seriously interested by No Boilerplates recent video where he kind of outlined Rust has the potential as an everything language with a very long life similar to C. \n\nI don't have any real experience in other languages, I hear many people not really recommend learning rust as your first language. Right now, I'm in IT with a major interest in cybersecurity, I have many security certifications. In my day-to-day, I don't really use any scripting/coding skills. I'm wondering how someone would attempt to learn how to code with Rust as their first language? \n\nI did a little bit of research of course, I hear the rust book is constantly mentioned, rustlings, googles rust book, and finally exercism for coding problems. All of these are not totally rigid, do you think I can actually build software by using these resources? \n\nI'd be curious to hear from anybody who learned rust as their first language. My plan is to code at least a little bit every single day even if it's only for 20 minutes. At least for a year.",
    "score": 37
  },
  {
    "type": "individual_post",
    "title": "Newbie to Rust here! Can you suggest a simple Rust program that’s fun to read and learn from?",
    "selftext": "I enjoy learning programming languages by reading and analyzing code and looking up parts of it rather than following traditional tutorials. Can you suggest a simple Rust program that’s fun to read and learn from? Would be nice that that project really takes advantage of the Rust language. ",
    "score": 55
  },
  {
    "type": "individual_post",
    "title": "Hydro - a distributed dataflow language and high-level distributed programming framework for Rust",
    "selftext": "",
    "score": 59
  },
  {
    "type": "individual_post",
    "title": "Hiring for Rust program management | Inside Rust Blog",
    "selftext": "",
    "score": 61
  },
  {
    "type": "individual_post",
    "title": "I wrote a programming language in Rust for procedural art",
    "selftext": "Hello, Rust community!\n\nI wanted to share that I’ve been working on a functional programming language aimed at generating procedural art. Although it’s still in the early stages, the language has a defined syntax and a comprehensive standard library. I’ve also been documenting the project on GitBook.\n\nI’m looking for users to help explore its potential use cases. There may be many creative applications I haven’t considered, and I’d appreciate identifying any gaps in its capabilities.\n\nThe language is implemented in Rust and runs an interpreter that compiles code into a collection of shapes, which are then rendered as PNG images. All code is distilled down to a single root function.\n\nAn example:\n\n    root = hsl (rand * 360) 0.4 0.2 FILL : grid\n    \n    grid_size = 10\n    \n    grid = t (-width / 2.0) (-height / 2.0) (ss (float width / grid_size) (collect rows))\n    \n    rows =\n        for i in 0..grid_size\n            collect (cols i)\n    \n    cols i =\n        for j in 0..grid_size\n            hsl (rand * 360) 0.5 0.6 (\n            t (i + 0.5) (j + 0.5) (r (rand * 360) (ss 0.375 SQUARE)))\n\nIf you’re interested in creative coding, I encourage you to take a look!\n\nGitHub: [https://github.com/giraffekey/xylo](https://github.com/giraffekey/xylo)\n\nDocs: [https://xylo-1.gitbook.io/docs/](https://xylo-1.gitbook.io/docs/)",
    "score": 44
  },
  {
    "type": "individual_post",
    "title": "Par Lang, an experimental concurrent language with an interactive playground made in Rust",
    "selftext": "Hey everyone!\n\nPerhaps you remember my crate for session types: https://github.com/faiface/par\n\nThey're very nice to use in Rust, but I was really wondering what it would be like to have a little programming language built fully on those concurrent semantics.\n\nSo I made a little experimental language I also called Par (I guess I'm obsessed with the word), and I think it turned out pretty cool!\n\nHere's a repo with **full documentation:** https://github.com/faiface/par-lang\n\nt doesn't seem unreasonable to consider this a different **programming paradigm.** It will probably take a little bit of playing with it to fully understand it, but I can promise that once it makes sense, it's quite beautiful, and operationally powerful.\n\nTo make it easy to **play with,** the language offers an **interactive playground** that supports interacting with everything the language offers. Clicking on buttons to concurrently construct inputs and observing outputs pop up is the jam.\n\n**Let me know what you think!**\n\n## Example code\n\n    define tree_of_colors =\n      .node\n        (.node\n          (.empty!)\n          (.red!)\n          (.empty!)!)\n        (.green!)\n        (.node\n          (.node\n            (.empty!)\n            (.yellow!)\n            (.empty!)!)\n          (.blue!)\n          (.empty!)!)!\n    \n    define flatten = [tree] chan yield {\n      let yield = tree begin {\n        empty? => yield\n    \n        node[left][value][right]? => do {\n          let yield = left loop\n          yield.item(value)\n        } in right loop\n      }\n    \n      yield.empty!\n    }\n    \n    define flattened = flatten(tree_of_colors)\n\n# Some extracts from the language guide:\n\nPar (⅋) is an experimental concurrent programming language. It's an attempt to bring the expressive power\nof linear logic into practice.\n\n- Code executes in **sequential processes.**\n- Processes **communicate** with each other **via channels.**\n- Every channel has **two end-points, in two different processes.**\n- **Two processes share at most one channel.**\n- The previous two properties guarantee, that **deadlocks are not possible.**\n- **No disconnected, unreachable processes.** If we imagine a graph with processes as nodes, and channels\n  as edges, it will always be a single connected tree.\n\nDespite the language being dynamically typed at the moment, the above properties hold. With the exception of\n_no unreachable processes_, they also hold statically. **A type system with linear types is on the horizon,**\nbut I want to fully figure out the semantics first.\n\n**All values in Par are channels.** Processes are intangible, they only exist by\nexecuting, and operating on tangible objects: channels. How can it possibly all be channels?\n\n- **A list?** That's a channel sending all its items in order, then signaling the end.\n- **A function?** A channel that receives the function argument, then becomes the result.\n- **An infinite stream?** Also a channel! This one will be waiting to receive a signal to either\n  produce the next item, or to close.\n\nSome features important for a real-world language are still **missing:**\n\n- Primitive types, like **strings and numbers.** However, Par is expressive enough to enable custom\n  representations of numbers, booleans, lists, streams, and so on. Just like λ-calculus, but with channels\n  and expressive concurrency.\n- **Replicable values.** But, once again, replication can be implemented manually, for now.\n- **Non-determinism.** This can't be implemented manually, but I alredy have a mechanism thought out.\n\nOne non-essential feature that I really hope will make it into the language later is **reactive values.**\nIt's those that update automatically based on their dependencies changing.\n\n## Theoretical background\n\nPar is a direct implementation of [linear logic](https://en.wikipedia.org/wiki/Linear_logic). Every\noperation corresponds to a proof-rule in its sequent calculus formulation. A future\ntype system will have direct correspondence with propositions in linear logic.\n\nThe language builds on a process language called CP from Phil Wadler's beautiful paper\n[\"Propositions as Sessions\"](https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions.pdf).\n\nWhile Phil didn't intend CP to be a foundation of any practical programming language (instead putting his\nhopes on GV, a functional language in the same paper), I saw a big potential there.\n\nMy contribution is reworking the syntax to be expression-friendly, making it more visually paletable,\nand adding the whole expression syntax that makes it into a practical language.\n",
    "score": 19
  },
  {
    "type": "individual_post",
    "title": "How mature is wgpu now? Can I use rust for a solo game dev hobby project now? Rust worth learning before c++(cargo>cmake) ? or c++ first(been trying for 2 months and think I'd be more productive in rust without worrying about cmake/build systems).",
    "selftext": "Is it worth learning rust, and then trying to make games as learning projects? I want to make 3d games, and wgpu looks like a great option because it provides directx12, vulkan, metal backends, and I like that it cuts out a lot of the boilerplate, there's also zig lang, which provides great c/c++ inter op, but doesn't have the dev ux of rust. So I'm mainly asking, can I learn gpu programming, make gpu accelerated stuff like let's say deep learning, or 3d game engine, using rust? is wgpu mature enough now that it can be used for these kind of projects, and provides good performance like c++(or close enough that it doesn't matter, and it's worth the productivity gains), and good for prototyping new ideas? Or should I just learn opengl then metal then vulkan using c++, or even zig? please let me know what the best options are: I mainly want to learn by making some sort of game engine/graphics gui programming, because seeing something on the screen is a great motivator. Another thing is that I want to build a strong foundation, learn good habits that would transfer well to when I learn c++ for gpu programming, it should be a smooth transition, and I would have experience with those low level concepts before just jumping into c++. I tried c++ with vulkan cmake vcpkg, but it was just way too hard in my opinion, I think either opengl, a game engine or something else might be better just to start with. Again this is where I'm asking for advice: should I learn opengl first or vulkan? or something like wgpu that lets me use it without the boilerplate, but still exposes me to the concepts?",
    "score": 39
  },
  {
    "type": "individual_post",
    "title": "Rust as my first beginner programming language.",
    "selftext": "I've always wanted to get into programming, being amazed with what people can do. I've only ever copied stuff like from Stack  and then put that into Microsoft Visual Studio Enterprise, if that matters, for free at the time, as I was in a trade school that was giving it out for free. Anyway, I have just always been overwhelmed, and I don't know where to start. I mainly just want to do this for fun to see where it goes. So would you recommend rust as a good beginner programming language, or is there another program in language that you would recommend to start with. \n\nTLDR, would you recommend this as a good Programming language to start with.",
    "score": 26
  },
  {
    "type": "individual_post",
    "title": "Are there famous videogames created with the Rust programming language?",
    "selftext": "I mean, if i think about gamedev the first languages that come in my mind are Java or C++, but i recently realized maybe gamedev is possible with Rust too. I couldn't find any valuable resources online so do you know some quite famous games created with the Rust language?",
    "score": 33
  },
  {
    "type": "individual_post",
    "title": "Black Horizon: Armada, a digital deck-building card game, completely written in Rust",
    "selftext": "Hi there! I would like to share with you our upcoming game Black Horizon: Armada. It's a digital deck-building card game set in an original sci-fi universe, where your aim is to build the strongest armada. It's written from the ground up in Rust, using wgpu as the render backend. One of our goals for this game was to try out using Rust for developing a game start to finish. Some of the things we've learned so far: Rust enums are amazing for modeling game state and network programming doesn't have to be awful. I would love to share our development journey with you going forward.\n\nSome of the topics I'm interested in discussing are:\n\n* Prototyping games in Rust without an engine\n* Event based UI for games in Rust\n* Event based networking for a turn-based game\n* Using Blender as a visual editor for an engineless game\n* Immediate vs retained mode graphics using wgpu\n* Writing a simple custom ecs in Rust\n* Using enums to model game state\n\nPlease let me know if you would be interested in more detailed dev logs in the future, and if there are any topics you would be interested in.\n\nOur project is also on Kickstarter, please check it out if you are interested [https://www.kickstarter.com/projects/blackhorizonarmada/black-horizon-armada-strategy-card-game](https://www.kickstarter.com/projects/blackhorizonarmada/black-horizon-armada-strategy-card-game)",
    "score": 37
  },
  {
    "type": "individual_post",
    "title": "Can one learn rust as first language following the roadmap.sh guide?",
    "selftext": "I see many experienced developers trying rust, but was wondering what if it is someone’s first programming language?\n\nEdit: I’m motivated. I’ll report back later. ",
    "score": 35
  },
  {
    "type": "individual_post",
    "title": "Will there be / is there a push towards Rust in graphics programming?",
    "selftext": "Hi All. Beginner Rust programmer here. In the middle of reading The Rust Programming Language, and have tinkered with a couple of projects in Rust. \n\nI also have an interest in graphics programming, and have wondered if there are any large efforts towards implementing Rust or having implementations in Rust towards graphics APIs? I’ve heard a lot of different things regarding this, with one comment I remember saying:\n\n “there are hundreds of game engines made in Rust, but no games made in those engines” \n\nFrom what i’m aware of, the graphics programming space is full of different APIs targeted towards different use cases and platforms, and i’ve specifically seen that there’s a lot of work towards wGPU implementations in Rust.\n\nBut would there ever be a justification for pushing C++ code bases towards Rust in the Graphics Programming Space? Why or why not? ",
    "score": 19
  },
  {
    "type": "individual_post",
    "title": "New Rust and systems programming community in Ghent, Belgium",
    "selftext": "I am a software developer using Rust on a daily basis in the railway industry. I am based in Ghent, Belgium and was missing the presence of a physical Rust community. Although I love Rust, I didn't want to exclude the C++ community or related topics. Rust is a great language but sometimes we are hyper-focused on the language itself. So I created a new community called [Systems Programming Ghent](https://sysghent.be/). I have a few ideas for events. They are listed on the website. \n\nEveryone is welcome!",
    "score": 25
  },
  {
    "type": "individual_post",
    "title": "A Programming Language Inspired by a Brazilian Dialect, Compiling to JavaScript and Rust",
    "selftext": "Hey everyone! I’d like to share a project I’ve been working on: **GoiásScript**, a programming language inspired by the *Goiás* dialect from rural Brazil. The goal is to create a fun and culturally rich way to learn and practice programming—especially for folks from the Central-West region of Brazil.\n\n🧑‍🌾 **What is GoiásScript?**  \nGoiásScript blends typical expressions from the Goiás dialect with the syntax and power of modern JavaScript. It supports advanced features like asynchronous programming, promises, and complex data structures.\n\nRepo: [https://github.com/Gefferson-Souza/goiasscript](https://github.com/Gefferson-Souza/goiasscript)\n\n⚙️ **Rust-Based Compiler**  \nRecently, I started building a GoiásScript compiler in Rust. This version takes GoiásScript code (`.gs`) and translates it into Rust code (`.rs`), optionally compiling it into a native binary. The idea is to take full advantage of Rust's performance, safety, and powerful type system.\n\nCompiler repo: [https://github.com/Gefferson-Souza/goiasscript-rust](https://github.com/Gefferson-Souza/goiasscript-rust)\n\n🚀 **Why Rust?**  \nRust is a modern language that brings:\n\n* **Performance**: Blazing fast with efficient memory management, no garbage collector needed.\n* **Reliability**: A strong type system and ownership model that ensures memory and concurrency safety.\n* **Productivity**: Great documentation, helpful error messages, and top-notch tooling.\n\nThese traits make Rust a perfect fit for building compilers and high-performance tools.\n\nIf you're from Goiás or just love programming languages with a cultural twist, I’d love your feedback—or even your contributions!\n\n**Let’s go, y’all! 💻🐂**",
    "score": 0
  },
  {
    "type": "individual_post",
    "title": "How can I do ... this: (fluid simulation planet)",
    "selftext": "Hey there.  About to take a sabatical from work to focus on personal projects.  I have a background in math and science and have been learning some more serious (relative to what I used to do) rust coding in last few years.\n\nI'm 90% sure that I need to learn some game-dev style programming to create the sort of interactive simulations that I'm interested in.\n\nToday I saw this: [Sebastian Lague: Coding Adventure Fluid Sim on a Planet](https://www.youtube.com/watch?v=8nIB7e_eds4)\nIt's in C#, but I'd love to get toward doing similar work in Rust.\n\nWhat should I be looking at learning?\n\nWGPU & compute shaders?\neGUI and raw code?\nA big framework like Bevy?\n\nAny pointers to what would be an effective way of creating interactive sims would be amazing.\n\n(As a bonus question: I mostly work in VR these days -- just for the screen realestate; using apple's visionOS -- I'm guessing there's no easy way to do rust work for VR nor work with swift.  So I'm fine just ignoring that.  But just in case I'm wrong I figured I'd mention!)",
    "score": 37
  },
  {
    "type": "individual_post",
    "title": "Multithreaded Rust in the browser via Emscripten",
    "selftext": "ok I finally got this working!\n\nit's tortured me for so long and held my project back. i'd have a bash at trying to get it going, find some slightly incomplete solution that didn't work, then give up. \n\nSome suggested emscripten/rust was *deprecated* so I wasn't even sure if it worked at all; and pivoting to 'wasm32-unknown-unknown' was also too much effort & upheaval for my codebase.\n\nI wanted to keep my browser demo running, so I was sticking to my main project in 1 thread ... a terrible shame considering multithreading was a huge reason I got into Rust :) \n\nAnyway, incase anyone else is trying to do this, and google lands them here..\n..here are some details collected in one place, covering things that had tripped me up along the way:\n\n**[1] Rust Cargo Config**\n```\n\n\n# In .cargo/config.toml` - settings that are passed to 'emcc' to build with multithreading.  \n[target.wasm32-unknown-emscripten] \n\nrustflags = [\n\n    \"-C\", \"link-arg=-pthread\",\n\n    # THIS LINE WAS MISSING BEFORE .. \n    \"-C\", \"link-arg=-s\", \"-C\", \"link-args=ENVIRONMENT=web,worker\", \n    # makes emcc gen extra .js (emulating threads through 'web workers'?)\n    # <project>.wasm,  <project>.js,  <project>.worker.js, <project>.ww.js\n\n    # other lines that I had before to no avail, still needed\n    # more opts passed to emcc\n\n    \"-C\", \"link-arg=-s\", \"-C\", \"link-args=USE_PTHREADS=1\",\n    \"-C\", \"link-arg=-s\", \"-C\", \"link-arg=WASM_WORKERS\"\n    \"-C\", \"link-arg=-s\", \"-C\", \"link-args=PTHREAD_POOL_SIZE=12\",\n\n    #additional detail needed for compiling a threaded environment\n    \"-C\", \"target-feature=+atomics,+bulk-memory,+mutable-globals\", \n\n    #... <i have other options unrelated to this issue>\n\n]\n```\n**\\[2\\] Making it rebuild the stdlb..**\n\ne.g. invoke builds with:\n```\ncargo build --target=wasm32-unknown-emscripten --release -Z build-std\n``` \n...to ensure it'll recompile the stdlib which I was certainly using\n\n**\\[3\\] Python customized testing server**\n\nThen for local testing: - I cut-pasted someones example python testing server modified to do \"cross origin isolation\". That let me get going before I'd figured out how to configure a propper server.\n\nThis is important to allow getting going without all the other heavy distractions taking you further away from actual gamedev IMO. Again I'd quit being unable to get this side working in some past attempts.\n\nThis is unrelated to Rust of course.. but it would have helped me to have this in one place in a guide aswell. I find dealing with info from disparate sources in \"web circles\" hugely distracting compared to my traditional focus of low-level graphics programming, and web tutorials assume a different knowledge base compared to oldschool C graphics/gamedevs like me.\n\n```\n# customized python testing server\n\nimport http.server\nimport socketserver\n\nPORT = 8000\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        self.send_header('Cross-Origin-Opener-Policy', 'same-origin')\n        self.send_header('Cross-Origin-Embedder-Policy', 'require-corp')\n        super().end_headers()\n        return\n\n\nprint(\"Starting a local testing server with Cross-Origin Isolation to enable SharedArrayBuffer use.. -port=\",PORT)\n\nHandler = MyHTTPRequestHandler\nwith socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n    httpd.serve_forever()\n```\n\n**\\[4\\] HTTPS  cross-origin isolation stuff**\n\nThen finally I got HTTPS working on my cloud instance by asking ChatGPT how to do it.. for any AI skeptics out there, this worked better than working through tutorials. I was able to tell it exactly what I had, and it told me how to change it. I know it's just assembling information from web scrapes, but being able to respond to natural questions and cross reference does make it more useful that traditional docs.\n\nI verified this worked by being able to spawn a couple of rust threads , and I could see their debug prints going asynchronously in parallel with my game loop. At that point I knew I was home and dry.\n\nFinally I can go all out with a tonne of plans .. maxing out my physics & animation, and procedural generation in the back ground..\n\nThanks for the people who at least confirmed it \\*was\\* possible - for most of the time I'd been looking into it, I wasn't even sure if it worked at all, getting the impression that the rust community considers emscripten 'deprecated'.\n\nI stick with it because I believe in keeping the C++ ecosystem going, so I think there will be ample demand for emscripten from JAI, Zig users and of course the C++ mainstream, and if we want to get bits of Rust into other long running native projects .. we'll want that support.\n\nMy own project is built around SDL2 + GL/webGL, which lets me run natively on multiple platforms aswell, and gives me continuity with my earlier C++ engines - I'd been able to take shaders/setup across. I need to dip back into C for interacting with platform libraries.  I've always used my own FFI bindings i.e. I was never waiting on rust community support for anything. (I knew that from a native POV, anything that works in C can be used from Rust aswell.)",
    "score": 19
  },
  {
    "type": "individual_post",
    "title": "Crust - A Scratch-like game development tool with its own text-based programming language!",
    "selftext": "Crust is a game development tool that allows users to create games using text-based programming, unlike Scratch, which is drag-and-drop based. Main features include but are not limited to:\n\n- Text-based programming language\n- A lot of functions from Scratch\n- Runs at a smooth 60 FPS instead of 30 FPS in Scratch\n- Supports all major platforms (Windows, macOS, Linux) except mobile\n- Open-source and free to use\n\nCheck it out on [Github](https://github.com/Muhtasim-Rasheed/crust-engine) or [Crates.io](https://crates.io/crates/crust-engine)!",
    "score": 17
  },
  {
    "type": "individual_post",
    "title": "Advantages and Adoption of Rust in the Videogame Industry",
    "selftext": "Recently, I have been developing a game in Rust just for fun, and a few questions have come up:  \nIs there any large or medium-sized company promoting the adoption of Rust in the videogame industry? Does Rust offer any advantages over C++ when developing AAA games?\n\nRust's advantages are evident when it comes to \"traditional\" software development, but what specific benefits does it provide in the gaming industry? A bug in a game will only affect the player, so I don't see it as a security risk. Beyond the fact that a game with many bugs can harm its reputation and reception, or that some online game bugs could impact other players' experiences, I am not sure if Rust has a clear advantage over C++ in this regard.\n\nThe potential advantages I can see is that, being a modern language, it could facilitate the use of best practices and speed up development times. This, in turn, could improve game quality and reduce the necessary budgets.",
    "score": 28
  },
  {
    "type": "comment_nuggets",
    "comments": [
      {
        "body": "I thought I was the only person in the world that actually likes the async/await implementation in Rust.",
        "score": 341
      },
      {
        "body": "Cargo is also the most admired embedded technology, whatever thats supposed to mean in this context.\n\nAnyway Cargo is definitly the best programming language build tool and package manager in my opinion, so well deserved.",
        "score": 325
      },
      {
        "body": "\\`\\`\\`  \n[`if let` temporary scope](https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html) — Changes the scope of temporaries for `if let` expressions.  \n\\`\\`\\`\n\nGates of Valhalla just opened, did they?",
        "score": 194
      },
      {
        "body": "`anyhow` actually supports backtraces. You just need to set `RUST_BACKTRACE=1` and call `.backtrace()` on the error:\n\nhttps://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.backtrace",
        "score": 192
      },
      {
        "body": "If rust analyzer is doing a long recompile on every change, it probably means it's compiling with different features or environment variables than what you are building your app with. By default RA uses the same target directory as as `cargo build` to store build artifacts and if they are making incompatible builds they end up causing each other to keep doing full builds.\n\nThis can be especially common with Bevy if you enable the bevy/dynamic_linking feature for your builds but not Rust analyzer's.\n\nEasiest fix is to tell RA to use a different target directory, see rust-analyzer.cargo.targetDir here: https://rust-analyzer.github.io/manual.html\n\nAnother fix would be to make sure all features and environment variables are the same so they can reuse each other's build artifacts, this can be tricky though.",
        "score": 164
      },
      {
        "body": "I would suggest learning some C basics and assembly since it will help motivate ownership and why Rust is considered 'safer'. But you don't have to do that.",
        "score": 166
      },
      {
        "body": "Disclaimer: I wrote this as a hasty not-quite-rant on some issues I've been thinking about recently. The tone came out as fairly negative, so I want to re-iterate: I love Rust! \n\nThe language really is great - I wouldn't have used it for 10 years, and continue to use it every day if I hated it. Huge props to everyone that's worked on it - everyone has put in a great deal of effort that shouldn't be ignored, and I want to take a second to recognize that effort and not just complain :)",
        "score": 163
      },
      {
        "body": "##Rust\n\n\n##Haskell\n\n\nIdk maybe Gleam.\n\n\nHowever I'm currently stuck in enterprise Java hell 😭",
        "score": 148
      },
      {
        "body": "I would recommend Rust. It will be a lot more familiar than C if you're coming from Python. The tooling for Rust is much better, so you'll be actually building things sooner.\n\nC isn't really lower level than Rust. It's just smaller, provides a much less powerful standard library, and makes a lot of stuff harder and more error prone. I'm not sure if there's really much to learn from spending a week writing a hash table that barely functions for example.\n\nYou can still learn C afterwards, at which point you'll hate how clunky everything is, how nothing important is really portable, and how much more work simple things are, but you'll be better at it for knowing there is another way.",
        "score": 122
      },
      {
        "body": "Probably the polonius integration end of this year will have pretty massive impact on the language as well as on future features.",
        "score": 122
      },
      {
        "body": "[`Vec::pop_if()`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop_if) is a highly welcome addition.",
        "score": 113
      },
      {
        "body": "Surprising. There are a lot of async fans in rust community, me including",
        "score": 111
      },
      {
        "body": "If you're learning to program as a hobby, I would recommend against Rust as your first language. Many of its strengths are not going to be relevant to you if, let's say, you're just trying to automate some spreadsheet work.\n\nMy recommendations nowadays are actually Python and JavaScript (as much as it pains me to say so). The TLDR is, Python is good for data processing; JavaScript is good for web scripting. They both allow you to get things done quickly, albeit imperfectly.\n\nRust in contrast makes you do things perfectly, but it's certainly not quick. So I say, start with one of those \"fast and loose\" languages, and later on if you decide to do this professionally (or tangentially so), explore Rust.\n\nClarification: when I say \"Rust is not quick\", what I meant is \"Rust is not the easiest/quickest to learn and write\", not \"Rust programs run slowly\". In terms of raw performance, Rust trades blows with C, which is basically as fast as it gets.",
        "score": 84
      },
      {
        "body": "Definitely zig. The tooling isn't great, and the documentation leaves something to be desired, but otherwise its fantastic. It's C with sane defaults + comptime. It's such a simple language that the lack of documentation doesn't even really hurt that much, because the source code in the std library is really easy to grok.\n\nI've done a couple of toy programs with it, but I wanna start a bigger project in Zig soon.",
        "score": 98
      },
      {
        "body": "From looking at the tools on that list, I would assume it is talking about building software for embedded systems, e.g. microcontrollers (or also probably including embedded-linux type systems). Build systems for embedded systems are generally Not Great, and being able to use Cargo for managing builds of embedded systems is a seriously big deal, even more so than typical for desktop C/C++ type work.\n\nBeing able to use rustup for pulling down cross compilation toolchains, cargo to install tools, and cargo for cross compilation and managing of dependencies is seriously a generational leap for a lot of embedded developers out there.",
        "score": 97
      },
      {
        "body": "> I think what people don't quite gasp is that if the end result is worse but much cheaper, some industries will take it anyway.\n\nYeah, this is essentially the [worse-is-better](https://www.dreamsongs.com/WorseIsBetter.html) thing: If you can get a _sorta_ working thing out the door fast, you can start earning money on it and (hopefully) iterate and make it better. Or just target users who would rather have a cheap product than a good product.\n\n> These people are very likely to embrace LLMs to avoid learning python, just because the bar is very low already.\n\nSee also \"low code\" and other attempts at \"programming in plain English\" (which goes back to at least COBOL). Part of the issue here is that we haven't reached any sort of saturation point for how many developers society wants, and training devs in traditional programming languages can be both time-consuming and costly.\n\nPart of the problem with LLMs, low-code, etc is that it's not necessarily cheap in the long run: People who have no idea about algorithmic complexity, using platforms that prioritise ease of getting started over correctness & efficiency, can wind up creating things that require a whole lot of resources and postmortems.\n\nAdvanced organisations can frame resource costs in terms of engineer-hours and have error budgets. It's a tradeoff. Less mature organisations will likely have a harder time reasoning about that tradeoff.",
        "score": 91
      },
      {
        "body": "Not surprised, Rust really feels great to work with like 95% of the time but the last 5% are pure agony when you either realize you designed a feature completely antithetical to the borrow checker or run into wild type errors with async. But other than that, just slap some `.clone()` here and there and it feels like you're working with a very high level and ergonomic language. Sum types, pattern matching and strong typing with traits really makes most other languages feel clunky and weird, every time I work with e.g. TypeScript at work I miss `Option`/`Result` and pattern matching.",
        "score": 89
      },
      {
        "body": "[mdBook](https://github.com/rust-lang/mdBook) was the tool used to transform the markdown into the web format.",
        "score": 94
      },
      {
        "body": "AI doesnt understand the actual libraries unless its actually consumed them in the training process and examples of their use. Its not really \"thinking\" it works great with say python,java,javascript and the most popular libraries for those languages because there is a truly staggering amount of data for them to work off of.\n\nthe way to get the most out of ai is context and constraints which rust is actually really good at so for more general questions or situations not related to a specific crate/library it tends to do really well. I strongly recommend tools like repomix when using claude or other llm's to help give the needed context for it to make or suggest or explain changes that are far more grounded in the reality of your actual code.",
        "score": 91
      },
      {
        "body": "Love the work. Once you're looking for a job in 5 years, one of the requirements will be\n\n - 10 years of experience in the Tidal programming language. ",
        "score": 90
      },
      {
        "body": "I found myself wanting trait upcasting for the first time this week, after over a decade of writing Rust code. The timing couldn't have been better for me!",
        "score": 90
      },
      {
        "body": "I just recently started C++ again after about 30 years, and oh my god, it's become an abomination. It took me about 4 weeks, doing an hour or so every day after work and more on the weekends, to get a triangle on screen with vulkan.\n\nCMake + vcpkg + VS2022 + ninja + glfw + vulkan\n\nBeen a professional programmer for decades though, currently working with Java fulltime, PHP before that, some C etc., so your mileage may vary. I've also done some Rust and Zig programming.\n\nAnd I took LOTS of time to pick the programming language and started in lots of languages, including Rust, Zig, Odin and plain C.\n\nRust was a no-go for me rather quick, because you need bindings and can't just use the C ABI directly. May not sound like an issue, especially since there are a lot of bindings for rust now, but it makes a difference at some point, when you find out that the lib you found, which would be perfect for your use case, just isn't available for rust. Also, rust syntax has some parts that IMHO are better than C++ (C++23), but the lifetime stuff ain't one. Rust wins in terms of build system though - took me days to get CMake + vcpkg etc. to what I needed, while the same can be done with a toml rust cargo file in mere hours or even minutes, if you know how to.\n\nZig was pretty cool, up until the moment I found out that the constant changes in the language break bindings all the time and while with Zig it's actually possible to directly use the C ABI, it's not like you can just call a function like you would call a zig function, it's actually a little more complicated. Build system might also be super powerful, but it took quite some time to get working. IMHO rust cargo is easier and better.\n\nPlain C is actually quite wonderful and super easy - the language itself has been used for decades now, doesn't really change anymore (except for small additions every decade or so), and it's compatible to everything else, because at the end of the day, everyone uses a C ABI. Issue though is that you will find lots more C++ resources for tutorials and the like than for C, and for some stuff getting C++ code is easier than C (e.g. enum to string for vk\\* for vulkan is easy with C++ VulkanHeaders package, but for C you have to download some out of date headers or code your own solution).\n\nOdin is pretty cool for game dev, but the missing docs were a no-go for me. Odin has \"built in\" vendor libs you can just use, e.g. vulkan, opengl, ... without much work, but at the same time it's not guaranteed that they are up to date and the docs are definitely less than what you get on the official sites of those libs.\n\nIF you have never done any graphics development, you might want to start with simple OpenGL tutorials (e.g. [https://nehe.gamedev.net/](https://nehe.gamedev.net/) was what I learned with back in the day - they are available in LOTS of languages). Pick whichever language you're at home to learn the basics.\n\nIF you have never done any programming at all, do yourself a favor and learn basics in any programming language first by doing Hello World and the like. In that case I would suggest learning C first, because it has way less magic than  most other programming languages, you get in contact with concepts like memory management (very important when doing graphics programming), and the language itself is one of the simplest out there - it only has around 30 keywords.\n\nOnce you have both programming and graphics programming basics down, you can pick your next step. But don't try to do everything at once, you'll just get frustrated.\n\nAlso, if you're just starting out, OpenGL is definitely simpler than vulkan, because it abstracts away a lot of the underlying stuff. Don't be deceived though, thousands of well known games have been built before DirectX12 or Vulkan was even a thing, so it's perfectly fine to not start with the \"latest and greatest\".\n\nEdit: Before starting, you should also read into differences of various graphics APIs and versions. E.g. OpenGL 1.0 isn't exactly the same as latest OpenGL 4.x, there's quite some differences.",
        "score": 9
      },
      {
        "body": "Any first programming language has to be easy and interactive. Mine was Logo.\n\nI have programmed in Logo, Fortran, Basic, Pascal, C, C++, Python, shell (various), perl, ocaml, matlab, vhdl, java, scheme, lisp, scala, rust and Haskell.\n\nI would give interactive environments (which don’t require explicit setup) a try. E.g. online notebooks, dev environments etc.\n\nOn your personal machine, interactivity is still important - worksheets, console/repl are great for learning.\n\nDynamic languages tend to be more interactive but also more error prone.\n\nMost people choose python for good reasons.\n\nI would prefer a more typesafe language with high interactivity like a repl. \n\nHaskell, scala are great but often frustrating for newcomers.\n\nOf compiled languages, garbage collected languages are easier to learn than those don’t have them - memory management is tricky and time consuming. Rust has the best compile time support for finding faulty thinking but is it the best environment to focus on learning algorithms/programming?\n\nI would think not. Neither is C, C++. Pascal used to be that kind of language but that’s a long time ago.\n\nI would also avoid multi paradigm languages for the first one. \n\nScala, C++ - not advisable for these reasons.\nPointers - avoid them on first take - go, C, C++, Rust\n\nObject oriented programming - I would argue it’s not essential. If you think it is - go for Java.\n\nBetween mutable and pure languages, people with mathematical background may take more easily to pure ones like Haskell while most prefer some imperative approach.\n\nLazy vs strict - most people will likely find strict more intuitive i.e. ocaml/scala/Rust over Haskell.\n\nDomain : AI vs algos/Math vs Systems vs Ui \n\nEach of the above domains have a most popular language. Just go with them rather than a niche language where you’ll get less help.\n\nAll being said, if someone asks me this question I would suggest\n\nhttps://reference.wolfram.com/language/guide/LanguageOverview.html\n\nOr \n\nhttps://www.kogics.net/kojo-ebooks\n\nIf someone wants a general purpose language as a first time language I would suggest Ocaml. For more mainstream I would say scala 3. Algebraic Data types are great!\n\nIf they are of the mathematical bent, then Haskell.\n\nIf it’s AI specific I would say Python.\n\nSome people may argue for Go but I think it’s a worthwhile suggestion as a first language to do concurrent code in since there’s one way of doing things unlike haskell and scala which have a dozen ways. It’s not safe wrt sharing mutable code.\n\nDoing concurrent code in Rust is not particularly easy even though it has the best compile time mechanisms to check for incompatible use. I would also ask why concurrent code needs to be written in Rust when there’s better support in languages like go, scala, Haskell.\n\nA somewhat moot point given concurrency shouldn’t be top of list for a first programming language.\n\nRust would be my recommendation only if someone is thinking about C, C++ since it’s definitely more beginner friendly wrt writing correct code.",
        "score": 1
      },
      {
        "body": "Well, I dunno, I spent a long weekend writing a ray tracer in Rust as my first exposure to the language, and by the end of that I had decided I'd never write with C++ \"for fun\" ever again.\n\nI still have to write with it for other people, though :-/\n\nAnd then I spent the next 6 months of weekends trying to implement a doubly-linked thread-safe scenegraph tree, and eventually gave up and used an arena like everyone told me to! :-P\n\nEDIT: I have more than 25 years of commercial C++ experience, and a decent amount of hobby-level Haskell experience, and I didn't find the transition very painful at all. I think one's background makes a big difference. I know of some younger Python & \"full stack\" programmers that would struggle a lot.\n\nEDIT: If you study modern C++ and understand why `shared_ptr` and `unique_ptr` exist, and use them religiously, and are aware of concepts like pointer aliasing and struct packing, and thread safety, then I don't think it's a large leap at all. But Rust makes all of this enforced, rather than just a bloody good idea.",
        "score": 77
      },
      {
        "body": "It's a play on Python's `from __future__ import braces` which is a rick-roll-style easter egg that raises a `SyntaxError` with the message \"Not a chance\".\n\nIn Python, imports from the `__future__` module are basically special feature flags that normally let you enable real future features for your module. For example, in Python2, you can add `from __future__ import print_function` to your script to get the Python3 behavior of `print` becoming a function, rather than a statement.\n\nThe easter egg pokes fun at users who have demanded that Python optionally allow use of braces, rather than whitespace, for lexical scoping.\n\nHere, u/sepease is making a joke, jovially implying that Rust would add a feature allowing you to use whitespace, rather than braces, for lexical scoping. For those that know the Python history, this is obviously a joke.",
        "score": 82
      },
      {
        "body": "Statistics says yes, there is likely someone out there that went that way. \n\nShould that inform you to select it as a first language? No.",
        "score": 80
      },
      {
        "body": "Rust is very far from a good first programming language.  I strongly recommend to start with a language that will give you a faster iteration and feedback loop such as Python or JavaScript.\n\nRust is absolutely not good for iterative programming because your program itself won't even run unless it's \"correct\".  It will not allow you any room for error and you will become very frustrated spending all your time on compiler errors instead of just your own logic and \"tinkering\".",
        "score": 61
      },
      {
        "body": "There has been a fair amount of negative chatter about Rust game dev from poking around online. The compile times are often complained about (but hasn't been so bad for me so far, we'll see how that is as my projects grow!). There was the comfy dev's break up letter (lots of interesting, good points but likely there's a bigger, long-term convo to have there). Jon Blow has a video saying Rust isn't good for game programming (clip titled \"Rust Will Lose\" 🙄). Embark ending funding for open source Rust projects after years of investment. This a pretty normal thing though—the great Language Wars. I'm sure folks have left Rust for Zig or Odin, etc. That's normal and to be expected. A lot of that stuff is just noise. But I do think it is up to the Rust Game Dev community to make the case for Rust being an excellent choice for game development beyond it just seeming like Rust should be a good fit for game development.\n\nGame development is also a pretty weird term. When I say it, I think of small indie games—a few people or so. I think of Pico-8. I think of Celeste, Balatro, Stardew Valley. I think of Cave Story. But I also recognize some people think of Baldur's Gate 3 or The Witcher or Call of Duty. There's some weird dynamics there. Could a large AAA game be made with Rust? I'd imagine with time and money, sure! And there'll probably be good things over C++ and bad things. Rust, in 2024, to me, seems well suited for making solid 2D games, ambitious 2D games, and small 3D games. Ain't nothing wrong with that! There are a lot of good, interesting games to be made within that space. And maybe it'll become more viable for larger 3D project in time. In my opinion, the Rust game dev community's goal should be: **make Rust an incredible choice for ambitious indie developers with programmers who want full control of the source, a top-notch dev experience, and a great open source ecosystem.** This means having stability, resources, and community support. And most importantly, shipped games! I believe the Rust game dev ecosystem evolving is dependent on there being interesting, finished, polished, games made with it. Console support will come in due time, just as it has with Haxe and other languages. It seems to be motivated by, honestly, money and the opportunity to make it on those platforms. The goal should be, IMO, how do we help the community make good games?\n\nI've rambled about the highlights and challenges of using Rust. So where have I landed and what am I doing? Well, right now I'm enjoying using Macroquad. I love how simple it is, as it's been great for learning Rust. Support for WASM, especially for smaller games, is absolutely essential. Macroquad's aim for targeting as many platforms as possible is really appealing. Macroquad's track record is fairly consistent—years of development. Although I do worry about it primarily driven by just one person and it not being stable yet. It's a risk I know I've taken. I've started to contribute to Macroquad (improving the website to start and then writing docs next), so hopefully I can be part of the solution to some of the challenges I've outlined here.\n\nUsing Bevy felt too much like learning Bevy and its ECS, not Rust. Too much at once for me. I'm quite interested in checking out Bevy, Piston, and Fyrox in the future more deeply once I've got more of a handle on Rust. I'm also curious about using SDL2 or Raylib with bindings or going even a little more lower level to learn. But I don't know if I want to go down that rabbithole quite yet.\n\nA stable landscape over time could look something like: engines like Fyrox & Bevy for more feature-full engines with advanced 3D capabilities & Macroquad for your go-to 2D and simple 3D library. Something neat that I haven't seen but think could be interesting: a Rust framework that makes it easy to script games with Rhai or Lua with live reload for fast prototyping. Then parts of it or all of it could be rewritten in Rust. Basically work quickly to start and then stabilize in Rust. Seems like it'd be very possible and an interesting experiment.\n\nIn summary: Rust's game dev ecosystem is still maturing and on its way. IMO, we need stable libaries and more educational resources. The ecosystem is pretty fragile right now, and I think stability will be bring growth and community ownership. And most of all, we need interesting, polished, shipped games. There are lots of defunct frameworks and engines, but also a handful of ones that persist and continue on! Macroquad, Bevy, Fyrox, Piston, and lower level bindings seem to be the most promising right now as of summer 2024. Who knows how that'll change and shift over time.\n\nBack to making small games and trying to create resources to help folks. Excited to be along for this journey with y'all!",
        "score": 10
      },
      {
        "body": "I'm a beginner programmer working in tech (consultancy, support, and client-facing software roles, not coding). I got hooked on Rust after a colleague introduced me to it while I was dabbling in some Python LeetCode problems. Rust’s potential as an \"everything language\" with its unique system for low-level performance and security really drew me in, much like it did for you.\n\nI started with [*The Rust Programming Language*](https://doc.rust-lang.org/book/) (often called \"The Book\"), which I found approachable as a beginner—just open the first chapter and start reading! I also asked AI tools whether Rust was a good first language for someone interested in programming and building cool projects. The consensus was that it might be overkill, but learning Rust can make other languages feel easier by comparison, and most concepts become clear with time (if there’s ever an \"end\", haha).\n\nI’ve been learning Rust off-and-on for about nine months now, and it’s definitely challenging for a beginner brain at times. But when broken down, most concepts aren’t too hard to grasp. My approach is to always have an active project—like solving problems on [*Advent of Code*](https://adventofcode.com/), [*LeetCode*](https://leetcode.com/), or [*Rustlings*](https://github.com/rust-lang/rustlings)—or working on small personal or work-related projects. Alongside that, I gradually read through resources like [*The Rust Book*](https://doc.rust-lang.org/book/), [*The Rustonomicon*](https://doc.rust-lang.org/nomicon/) for deeper insights, [*Rust Design Patterns*](https://rust-unofficial.github.io/patterns/) for practical tips, and blog posts like [pretzelhammer’s Rust blog](https://github.com/pretzelhammer/rust-blog). I keep these bookmarked on my phone to read during spare moments (hopefully instead of doomscrolling!).\n\nRust’s community is amazing, and the language is well-documented with tons of discussions online. My advice is to jump in, stick with your plan to code a little every day, and keep chipping away. I’m only nine months in with some breaks, and I already feel like I can actually code now—you’ll be surprised at how much you can learn with consistent effort!",
        "score": 3
      },
      {
        "body": "It's called \"Rust\", not RUST. It's not an acronym.\n\nYes, I'm certain that Rust improves security. It doesn't guarantee it, mind you, and the programmer is still responsible for the implementation, but it does make it easier to avoid issues.\n\n* Most importantly, Rust makes it easier to design, distribute and consume high-quality libraries. This should not be underestimated. The best code is the one which you didn't have to write, where many experts put in the effort to avoid bugs and vulnerabilities, and many real-world consumers have tested the implementation and helped iron out the kinks. Rust's package management story is best in class, and the language & its tooling enable writing high-quality reliable libraries. You don't have interpreter version conflict, you rarely have silent API breakage, and you don't have a hell of microdependencies, like in JS (Rust crates can be small, but that's because they provide a self-contained small unit of functionality, rather than just because of fragmentation). \n\n* Rust's type system enables writing reliable code. This includes the proverbial memory safety, since it's enforced by the type checker (borrow checker is part of it). But this also includes encoding of more complex invariants via algebraic data types, traits and compile-time trait-based metaprogramming. Many important conditions which would be checked at runtime or only manually in other languages can be fully encoded in the type system in Rust, and unconditionally checked by the compiler. You can check that all disjoint cases are covered. You can check that pointers are never null, that all errors are always handled (even if by panicking or propagating upwards).\n\n* This also feeds into the previous point about libraries. Rust's libraries are so solid because they can enforce many complex conditions via the type system. In other languages, you need to worry whether some API is multithreading-safe, or re-entrant, or has some shared global state, or whether you need to hold some mutex while performing an operation, or whether some object can be mutated while you're working with it. In Rust, these conditions can be encoded in types and checked automatically. This also makes it easier for library authors to check _what exactly_ they guarantee, which means implicit compatibility breakage is less common. \n\n* Rust's infrastructure helps with code quality. You have a state of the art autoformatter and linter out of the box. Many errors, including the ones which cause critical vulnerabilities, are some stupid simple stuff like \"dangling else\" or \"error while copy-pasting code\", which can be easily caught by linters.\n\n* Rust comes with a built-in test framework, which is... good enough. Not stellar, but has all the basic features and is very easy to use. This means it is used in most Rust projects, further helping to deal with bugs. And if you want more complex checks, you can easily pull crates for fuzzing, property testing, snapshot testing, UB checking etc.\n\n* Similarly, rustdoc is available out of the box and easy to use. This means that writing some reasonable documentation is both easy and expected. Which, in turn, makes it less likely to have undocumented behaviour, or erroneous API expectations. It's not perfect, in the end the programmer is responsible for proper documentation, and some people just... are not. But it's there, and thus it feeds into Rust's reliability story.\n\n* Rust is designed with security-first mindset. APIs are implemented in a safe-by-default way, with more dangerous alternatives being explicitly marked. Stuff like implicit type coercion, which is a common source of bugs in languages like C++ or Scala, are absent from the language. The language favours explicitness, and direct statement of intent over an API magically trying to read your mind and do the right thing (which commonly fails). The standard library and core libraries are designed with meticulous attention to detail.\n\n* Importantly, even _potential_ vulnerabilities are treated as a major issue and must be fixed. In most other languages, people don't try to achieve absolute guarantees (not the least because the languages make it impossible). For this reason error-prone or leaky APIs are often ignored, unless an actual proof-of-concept vulnerability may be produced. But producing a vulnerability takes time and effort, and many people who may hit it won't know about it, or care to send bug reports to the library maintainers. In Rust, it is enough to show a hole in guarantees to warrant a fix. People don't wait until those holes cause real-world vulnerabilities. This proactive approach is doubly important, because real-world vulnerabilities are often produced via chains of low-severity minor vulnerabilities which people didn't bother to fix, but which interact catastrophically in certain scenarios.",
        "score": 1
      },
      {
        "body": "Hi, I worked in Gamedev 2 years and have something like 100k lines of Rust shipped outside it. Here's what I think:\n\nGamedev requires a lot of prototyping and fast changes. Each game mechanic that lands is version 3 or 10 from original concept. The code quality decreases with time, becomes spaghettish at the end. Furthermore, it's more centered around \"human testing\" as opposed to automated one.\n\nRust compiler is quite unforgiving, slowing down each \"prototype\" iteration. You literally prefer falling apart Lua scripts to bulletproof code, for the sake of iteration speed in gamedev. So that's a first no.\n\nSecond, lack of quick-to-deploy UI (that is well standardized) is a big no. In particular there is no popular \"flow/tree widget\" that you know will be supported for 2-3 years. While working on a game, you often need to build several small apps (typically C# / QT) to support artist's work on particular game mechanics. These are super custom and never very well designed/developed, just enough to get through the finish line.\n\nRust seems to target different type of development - well unit tested, well defined, well designed and bulletproof at the end. Games are the other side of each of these spectrums.",
        "score": 69
      },
      {
        "body": "Every programmer in the world have trouble with lifetimes.\n\nThe only difference: with Rust one have to fight them **during compilation time**, while with most other languages you fight them **with a debugger**.\n\nMost of the time dealing with compiler is easier.\n\nOn [URLO](https://users.rust-lang.org/) there were few discussions with some people who studied Rust as first ever language and none of them had issues with lifetimes per see.\n\nI would even say that **the only** problem of Rust as the first language (but it **is** a serious problem) is lack of suitable tutorials: most Rust tutorials assume you are programmer already, just not Rust programmer.\n\nOne could take one look on an attempt to bring notion of ownership and borrow (very simple and obvious things) via the stack and heap (quite convoluted and non-obvious thing for someone who haven't programmed before), it's done in [The Book](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html) – and it would be easy to understand what do I mean.",
        "score": 47
      },
      {
        "body": "For me, Rust is nice because it adds a lot of nice, little helper methods.\n\nYes, this method can easily be replaced. But a lot of methods can. Heck, even your bool.then() can be argued as not being needed as you can just use an if.\n\n  \nThe nice thing about these little helper methods isn't always in the amount of code they save but also because they make it much easier to get what is going to happen. If I see `let user = some\\_func(&users\\[0\\]).then(||users.pop())` then only add the end does it become clear that we called `some_func` to decide if we want to pop something or not.\n\nWith `let user = users.pop_if(some_func)` we know pretty much from the start what we are about to do.\n\nAlso, this assumes that `users` is not empty. If it is allowed to be empty then the code it replaces becomes even more annoying `let user = ((!users.is_empty()) && some_func(&users[0])).then(||users.pop())`\n\nstill nothing outrages I suppose but... I take the pop_if version thank you very much.",
        "score": 74
      },
      {
        "body": "I would not say I want to *work* with it, but I'd love to take the time to get a feel for Elixir or Erlang (or maybe gleam). I have an actor library that I would like to improve by seeing how those languages approach actors. That said, Rust is what I will be using to actually build things.",
        "score": 69
      },
      {
        "body": "It was known as a bug since at least 2022 and was acknowledged as such immediately after being reported, anyone telling you it was a skill issue was clearly being silly and can be disregarded: https://github.com/rust-lang/rust/issues/103108",
        "score": 69
      },
      {
        "body": "I've tried to check out and explore as many libraries, frameworks, and engines as possible to get the lay of the land before picking one for my first non-trivial Rust game. I like to read the documentation, experiment with the examples, and make simple games. Crates I've checked out: Bevy, Macroquad, Tetra, ggez, abg, Comfy, good-web-game, Pikuseru, bracket-lib, Raylib bindings, and SDL2 bindings. I've read Hands on Rust and gone through the examples. I've made few prototypes: a top down 2D shooter with Bevy, simple vertical shmup with Tetra, and a Sokoban client with Macroquad.\n\nI'll start with the positives, of which there are many!\n\nRust feels really great to program in coming from TypeScript, Ruby, GDScript, and Haxe. Rust Analyzer + Neovim + CoC works really well, with inline docs, and instant feedback on changes. Structs + traits + enums are some of my favorite parts of the language. The compiler and clippy are a big help for learning the language. Cargo works well and seems stable. I love that I can have multiple bins in my project, which is great for dev tools and experimenting. I've been putting my game code in `src/lib.rs` and then `src/main.rs` is the main entryway, and then `src/bin` has my custom dev tools (a level editor, an input tester, and animation tester, etc.). Being able to `cargo check` all the bins quickly has been useful. Testing in Rust is top-notch—I unit test my functions where it makes sense (e.g., some math functions). And I've been writing integration tests for verifying asset files. For example, I've got an integration test that checks that all of the Sokoban levels included in the game are valid. Really thrilled with the language, and while the learning curve is steeper than other ones, I've found it to be exciting and rewarding. I'm still fumbling my way through architecture—I'm passing a global Context struct around because it's not clear how else to do that without singletons or some sort of global data structure that other languages have.\n\nRust has a rich ecosystem of game dev crates. From windowing to bindings to frameworks to engines. There's a lot happening, which is a good sign. I'll give an example: with Macroquad, there isn't built-in gamepad support yet, but there's a crate called `gamepads` that easily drops in and supports WASM. It works quite well. Excellent! Want to load maps from Tiled? There's a crate for that. Want to read Aseprite files directly into your game? There's a crate for that.\n\nThe community has been kind, and its active. I really love seeing all the various projects, updates, and writing about what's happening. Not every language is like that, and it's special and something worth acknowledging. Game dev in Ruby and Haxe are pretty small and quiet comparatively.\n\nThere are interesting games being made and shipped with Rust. I just bought and played USG by Pollapee on Steam. It's made with the Tetra crate. Tiny Glade made in Bevy looks really chill. doukutsu-rs is an impressive re-implementation of one of my favorite games, Cave Story. Veloren looks neat as heck. There are many more in development that I've checked out too. I think we'll only continue to see more and more interesting, high quality games ship with Rust. Shipping good games will help bring people to the language and a given engine/framework/library. I've also seen some interesting usecases of Rust being used in multi-language tech stacks (e.g., for writiting libraries used by other languages/tech).",
        "score": 21
      },
      {
        "body": "Rust developer of about a decade here. From the top:\n\n1. Move on Copy-types and when the function has to hold the value for longer (for example a `new` function that puts the data into the returned object), because then the caller can decide if it has to be cloned.\n2. Whenever a type refers to data outside that type. This happens when I want to avoid having to clone (or use Rc/Arc). This is only useful for short-lived types like Iterators, otherwise the user of that type quickly runs into having to manage self-referential data. Not fun.\n3. The general rule is: anyhow for programs, thiserror for library crates. My current project actually uses both in a library crate, thiserror for exposed errors and anyhow for errors that are handled internally.\n4. Very rare. I’ve only done this on newtypes, and I don’t do that very often. My current project has one that wraps `Arc<str>`, where it is very useful.\n5. I try to use functional operations (map, fold, collect, chain, filter, etc) whenever possible. One major caveat is that async is really hard to do with them, so when I need async operations I sometimes fall back to `for` loops. Also, I use `for` loops for side effects (like setting some value somewhere else). I don’t use for\\_each, I don’t see the value. `enumerate` is needed when you need the index for something, that’s not a style question.\n6. That’s something that comes with experience and sometimes trying to fix compiler errors. Your example looks a bit weird because the generic type has the same lifetime as the reference to it, but maybe it doesn’t matter in this case that they’re tied together.",
        "score": 65
      },
      {
        "body": "    #![feature(import_trait_associated_functions)]\n    \n    use std::iter::Iterator::{collect, filter, map};\n    \n    fn get_ids2(data: impl Iterator<Item = Widget>) -> Vec<Id> {\n        collect(map(filter(data, |w| w.alive), |w| w.id))\n    }\n\n[RFC 3591](https://github.com/rust-lang/rust/issues/134691)",
        "score": 58
      },
      {
        "body": "Rust is not exactly a great first language,\n\nEven seasoned rust devs still have trouble with lifetimes etc",
        "score": 55
      },
      {
        "body": "It will be in 2024 edition, but not 1.85.0 see https://github.com/rust-lang/rust/pull/132833",
        "score": 57
      },
      {
        "body": "> But Rust fundamentally treats 1 crate = 1 compilation unit, and that really hurts the end-user experience. Touching one function in Bevy's monorepo means the entire crate gets recompiled, and every other crate that depends on it. I really really wish that modifying a function implementation or file was as simple as recompiling that function / file and patching the binary.\n\nI don't want to nit-pick here because I agree that the experience is bad, but I feel like a lot of people misunderstand Rust compilation by incorrectly comparing it to C++. I don't mean to patronize if you already understand Rust compilation very well, but hopefully this will be educational for some readers.\n\nThe Cargo profile setting `incremental = true` will try to prevent the entire crate from being recompiled when any part of it changes. Incremental compilation is enabled by default in the dev profile (plain `cargo build/test/run`). I don't see any mention of it in the bevy repo, but probably my searching is just poor. The problem with incremental compilation is that very strongly depends on CGU partitioning and whether the functions in your crate are compiled with LocalCopy (like a header) or GloballyShared (like a .o) codegen. Essentially all that matters is the total size of dirtied CGUs. If you modify some function that gets LocalCopy codegen which is also referenced by every CGU in the crate, the incremental compilation system doesn't help much. But if the current crate has a lot of CGUs and you edit a GloballyShared function, only its CGU needs to be recompiled. Most of the design of the rustc incremental compilation system focuses on caching queries and getting the query invalidation right; I think that for large projects which are doing incremental `cargo build` not `cargo check`, all the query juggling is irrelevant. The query caching is very important for `cargo check` times, but as soon as you want to generate code the most important factor is how much IR is handed off to LLVM.\n\nNone of that is about the dependencies of the changed crate.\n\nIn C++ you can modify an implementation file and just recompile that one file and re-link. In Rust, the primary reason you can't do that is that the Rust language doesn't let you separate headers and implementation. Rust still has headers, but automated. They're called rmeta files (or the rmeta section of a rlib file). Compiling a crate (in any mode other than `cargo check`) first emits an rmeta file, then an rlib file. Compilation depends on the contents of the rmeta file/section of dependencies. The problem is that any change to the source code will change the rmeta file, and Cargo/rustc only understands that means a rebuild is required. If you were constantly editing C++ headers, you'd expect to have poor incrementality... but also you'd take some kind of action to make sure you didn't need to edit headers all the time.\n\nIn addition, incrementality in Rust is very much at odds with optimizations, because CGU boundaries (which you do not have control over!) block inlining. Adding `#[inline]` is the same as moving a function to a header file; they get pasted into every CGU that uses them, every copy gets separately optimized by LLVM, and in my experience they are only deduplicated by LTO, not by normal linkage.\n\nSo I don't think the problem you're running into is \"The Rust compilation model\", it's the fact that rustc's incremental compilation system is insufficient for your workflow. The problem is not with the language, the problem is in the compiler. If the incremental compilation system understood incremental updates to dependency rmeta files and could only recompile what was changed, these muti-crate workflows would be significantly improved.",
        "score": 24
      },
      {
        "body": "Considering I've never even seen a `*const dyn Trait` or a `*mut dyn Trait` in any rust code in the wild, I don't think it's that relevant.",
        "score": 60
      },
      {
        "body": "WGPU developer here. We did have some performance regressions in 22.0, but we think they should be fixed in 23.0. Performance is important to us, but at the moment bringing WGSL and the API into compat with the latest version of [the spec](https://gpuweb.github.io/gpuweb/wgsl/) are our top priorities.\n\nBackground color: Animats shows up a lot in wgpu GitHub with vague complaints, generally wanting us to debug/optimize his code. I said [this](https://github.com/gfx-rs/wgpu/issues/6434#issuecomment-2444733606), and I guess that hurt his feelings, so he's undertaken a [grief](https://www.reddit.com/r/rust/comments/1e6j8sk/comment/lunt529/) [campaign](https://old.reddit.com/r/rust_gamedev/comments/1giujbk/wgpu_21_performance_drop/?cache-bust=1730675881069).\n\nI understand it's frustrating when an open source project doesn't jump on your performance regressions the moment you report them. WGPU has lost two major contributors to career changes, and we should probably be doing more to build participation back up. My personal contribution to the problem is slow patch reviews, but we could do better with docs, onboarding, and other issues as well. But Animats here is not, and has not generally been in the past, very helpful.",
        "score": 54
      },
      {
        "body": "It has a GitHub\n\nhttps://github.com/rust-lang/book",
        "score": 58
      },
      {
        "body": "If you haven't yet, you should post this on /r/ProgrammingLanguages  as well.",
        "score": 54
      },
      {
        "body": "I think errors are often misunderstood - so many times I've seen a huge `thiserror` enum in a web server/cli tool/etc where you're never actually matching against the individual variants, just using it to get the `From` impl. At that point, just use anyhow.\n\nI think there are some people that hear \"Rust has great error handling\", and think that means that you get great error messages without thinking about them, but I'm not sure there's any language that can do that. Rust doesn't give you good errors, it gives you control over errors.\n\nIn many libraries I maintain, I just have `struct Error(String, Backtrace)`, since, while there are different reasons this error can happen (i.e. different \"variants\" if it were an enum), a user of my library wouldn't necessarily want to match on this. For example, at a previous job, I maintained a library that was validating a custom cryptographic protocol. Our error enum looked like this:\n```\nenum Error {\n  MalformedData,\n  FailedToVerify,\n}\n```\n\nEach of these variants could have many different causes, for example, malformed data could be:\n - the input was not valid CBOR\n - the arrays in the CBOR had the wrong lengths\n - the data contained invalid indices into data stored somewhere else within itself\n\nAll of these could have been separate error types.\n\nSimilarly, failure to verify could have been for 1 of about 10 different reasons. But a user of the library doesn't care. They only care about whether a failure was due to the data being malformed, or just wrong.\n\nI agree with OPs complaints about backtraces. IMO they're often poorly handled, and languages with a VM often have more information floating around to at least point you to where the error happened. I'm still waiting for the \"perfect\" error crate that solves this, because it feels extremely solveable, but I can't put my finger on exactly what it would look like...\n\nRegarding the orphan rule, it's bitten me a few times, but considering the alternatives, I'm glad it's there. But I do wish there was a way to turn it off, perhaps with the consequence that it's only allowed in binaries and not libraries (or at least disable publishing such libraries to crates.io). Some way of saying \"I know what I'm doing, just use this impl\"",
        "score": 48
      },
      {
        "body": "> I want to understand how things work under the hood and eventually build low-level tools or libraries.\n\nStart with C then.\n\nUnlike Rust, C won't hand hold you from making mistakes, instead leaving you to understand how things work under the hood if you wanna make your code work for you.\n\nI hate C, but credit where credit is due.",
        "score": 56
      },
      {
        "body": "> I’ve not seen any other language that even comes close to the convenience of Rust’s pipelines\n\nThat'd be bash, or shell scripting more generally.\n\n`cat some-file | sort | uniq --count | sort --reverse --numeric-sort | head --lines=10` has data flowing cleanly left to right, transformed by each subsequent command, and you can even hit TAB right in the shell to get completion for your command or argument, or a noise telling you it doesn't exist.\n\nAnd since it's an interactive shell, everything has shorthands, so if you're really proficient with it you can whip up `cat some-file | sort | uniq -c | sort -rn | head -n 10` in 10 seconds flat. Not readable in the slightest but perfect for a one-off command.\n\nAnd this was all in place since at least the 90s.\n\n------\n\nAnother feature that bash has and most languages inexplicably lack is execution tracing. Instead of trying to fiddle around with breakpoints, in bash you can just `set -x` at any point and the interpreter will print every line it executes with variable values already substituted. You can turn it on and off whenever you like, so you can only trace a certain part of the code, etc. The only other language that has it is Erlang, by necessity, because debugging a soft-realtime distributed system with breakpoints is a completely lost cause. There is no reason Python couldn't implement the same thing - cpython is just an interpreter - but it seems they never bothered to do it, so debugging Python is quite unpleasant. I get why compiled languages cannot do this, but for an interpreted one there is really no excuse.",
        "score": 44
      },
      {
        "body": "Developer of Hydrofoil Generation here. Rust codebase, custom engine and all the jazz.\n\nIn my opinion, no.. it's not going to happen. Reasons:\n\n1. Inertia. Gamedev is an industry with a huge inertia, projects last a long time and new projects tend to leverage a lot of legacy tech. Gamedev was one of the last industry to move from C to C++ and it hasn't embraced \"modern C++\".\n2. Most games are now based on established engines, notably Unreal and Unity with everything else chasing from a very big distance. This means studios will use whatever those engine will use.. and that's not Rust.\n3. For the few studios that choose to start a new project based on a new custom tech Rust doesn't offer much compared to C++. Interactions with existing native SDKs is either harder than C++ or straight impossible. Rust doesn't solve any gamedev specific problem.. compile times are as bad as C++.. sure code and experience is a little better when the problem is not triggering the borrow checker (rare in gameplay code, more common in engine code) and MUCH worse when trying to model the problem with approaches that are not compatible with the \"Rust way\".\n4. There are better alternatives for those studios willing to take risks on unproven techs.. first of all Jai (once it hits public availability) that is \\_actually\\_ solving gamedev specific problems (compile times, deep build customization, extreme metaprogramming etc) but also the other plethoras of \"better C\", from Zig to Odin to C3 to D and so on. All of these offers better solutions for gamedev than Rust.\n\nHaving said that... obviously developing a game in Rust is not only possible but also a pretty enjoyable experience.",
        "score": 35
      },
      {
        "body": "The survey says that Rust is used by [12.6%](https://survey.stackoverflow.co/2024/technology#most-popular-technologies) of respondents. That's a lot, and compares well with objectively popular languages like Go (13.5%), C (20.3%), C++ (23%). It is a top 10 language not counting shell/SQL/HTML.\n\nJust look at the growth in the last few years.\n\n- Didn't crack the [top 25 in 2018](https://survey.stackoverflow.co/2018#most-popular-technologies)\n- [3.2% in 2019](https://survey.stackoverflow.co/2019#most-popular-technologies)\n- [5.1% in 2020](https://survey.stackoverflow.co/2020#most-popular-technologies)\n- [7.03% in 2021](https://survey.stackoverflow.co/2021#technology-most-popular-technologies)\n- [9.32% in 2022](https://survey.stackoverflow.co/2022/#technology-most-popular-technologies)\n- [13.06% in 2023](https://survey.stackoverflow.co/2023/#technology-most-popular-technologies)\n\nSo to rebut your baseless claim, it seems like Rust is used by many people and it is growing with time.\n\nMany people over the years said that as it became more popular fewer people would love the language. People forced to use it at work would resent Rust because dealing with other people's code, especially older legacy code is hell. But that's not what happened. Despite the community of Rust developers quadrupling in the last 6 years, it has remained loved by 78.9%, 83.5%, 86.1%, 87%, 86.7%, 84.7%, 82.2% of developers, #1 each year.",
        "score": 37
      }
    ]
  }
]